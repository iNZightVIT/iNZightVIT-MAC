.packageName <- "gWidgets2RGtk2"
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gWidgets2RGtk2-package.R"
##' The \pkg{gWidgets2} package provides a programming interface for
##' making graphical user interfaces within R. The package is a
##' rewrite of the \pkg{gWidgets} package, introducing a few external
##' changes but a significant number of internal ones. The package
##' relies on one of several underlying toolkit packages providing
##' access to the graphical libraries. This package provides the
##' implementation to interface with the underlying \pkg{RGtk2}
##' package.
##' 
##' @author
##' John Verzani \email{jverzani@@gmail.com}
##'
##' Maintainer: John Verzani \email{jverzani@@gmail.com}
##' @param ... passed to constructor
##' @aliases gWidgets2RGtk2-package
##' @name gWidgets2RGtk2-package
##' @docType package
##' @title gWidgets2Rtk2
##' @keywords package
NULL


##' @import memoise
##' @import methods
##' @import RGtk2
NULL

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/misc.R"
## miscellaneous functions
##' @import gWidgets2
##' @include gWidgets2RGtk2-package.R
NULL

##' toolkit class for RGtk2
##'
##' @name guiWidgetsToolkitRGtk2-class
##' @export
setClass("guiWidgetsToolkitRGtk2",
         contains="guiWidgetsToolkit")

## some special class unions so we can have easier to deal with default
## setClassUnion("IntegerOrNULL", c("integer", "NULL"))
## setClassUnion("CharacterOrNULL", c("character", "NULL"))
## setClassUnion("LogicalOrNULL", c("logical", "NULL"))
## setClassUnion("LogicalCharacterOrNULL", c("logical", "character", "NULL"))


## Pango Scale for converting between name and numeric value
PangoScale <- c(
               "xx-large"= PANGO_SCALE_XX_LARGE,
               "x-large" = PANGO_SCALE_X_LARGE,
               "large"   = PANGO_SCALE_LARGE,
               "medium"  = PANGO_SCALE_MEDIUM,
               "small"   = PANGO_SCALE_SMALL,
               "x-small" = PANGO_SCALE_X_SMALL,
               "xx-small" = PANGO_SCALE_XX_SMALL
               )

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtk-misc.R"
##' @include misc.R
NULL

##' method for stopping getWidget
##'
##' @inheritParams gWidgets2::getWidget
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method getWidget RGtkObject
##' @S3method getWidget RGtkObject
getWidget.RGtkObject <- function(obj) obj

##' S3 method for stopping getBlock
##'
##' @inheritParams gWidgets2::getWidget
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method getBlock RGtkObject
##' @S3method getBlock RGtkObject
getBlock.RGtkObject <- function(obj) obj




##  Font method for gtk object
## 
##  @export
##  @rdname font
## "font<-.RGtkObject" <- function(obj, value) {
##   ## set fonts from value
##   ## value might be a vector, we use a list -- from .fixFontMessUp
##   if(!is.list(value)) 
##     value <- sapply(value, identical, simplify=FALSE)
    
##   string <- ""

                   
##   ## do family, weight, style
##   for(i in c("family", "weight", "style")) {
##     if(!is.null(value[[i]])) {
##       x <- .font.styles[[i]]
##       ind <- charmatch(value[[i]], x)
##       if(!is.na(ind)) {
##         string <- paste(string, x[ind[1]], sep=" ")
##         if(i == "family")
##           string <- paste(string,",", sep="")
##       }
##     }
##   }
  
##   ## size can be integer or name -- relative to 12pt
                   
##   if(!is.null(value$size)) {
##     ## is it numeric or character?
##     warn <- getOption("warn"); options(warn=2) # hack to avoid warning -- we want an error here
##     out <- try(as.integer(value[['size']]), silent=TRUE)
##     options(warn=warn)
##     if(!inherits(out, "try-error"))
##       string <- Paste(string," ",out)
##     else if (!is.na(ind <- charmatch(value[['size']], names(fontSizes)))) # fuzzy match?
##       string <- Paste(string, " ", paste(ceiling(12*fontSizes[ind[1]]),"px", sep=""))
##   }
##   string <- gsub(",$","",string) # strip , if present
  
##   if(string != "") {
##     fontDescr = pangoFontDescriptionFromString(string)
##     obj$ModifyFont(fontDescr)
##   }
  
##   ## colors
##   if(!is.null(value$color))
##     obj$modifyFg(GtkStateType[1], value[['color']])
  
## }




## mouse click processing

##' Return TRUE if first mouse click
##'
##' To be called from key-press|release-event
##' @param e event for mouse press
##' @return TRUE or FALSE
isFirstMouseClick <- function(e) {
  if(!is(e, "GdkEvent"))
    stop("Must pass in an event")
  e$getButton() == 1
}

##' Return TRUE/FALSE if right mouse click
##'
##' To be called from key-press|release-event
##' @param e event for mouse press
##' @return TRUE or FALSE
isRightMouseClick <- function(e) {
  if(!is(e, "GdkEvent"))
    stop("Must pass in an event")
  
  e$GetButton() == 3 ||
  (is_MacOSX() && e$GetState() == GdkModifierType['control-mask'] && e$GetButton() == 1) 
}


## for drag and drop we define some global values

## parameters
TARGET.TYPE.TEXT   <- 80L                # our enumeration
TARGET.TYPE.OBJECT <- 81L                  
widgetTargetTypes <- 
  list(text = gtkTargetEntry("text/plain", 0, 
         TARGET.TYPE.TEXT),
       object = gtkTargetEntry("text/plain", 0, 
         TARGET.TYPE.OBJECT))

## an environment to store objects and times when dragging and dropping
.dnd.env <- new.env()
.dnd.env[['last_time']] <- 0

###
##################################################
## Map between R class an dGObject class
## right way, but was not working...
## RtoGObjectConversion <- function(x) UseMethod("RtoGObjectConversion")
## RtoGObjectConversion.default <- function(x) "gchararray"
## RtoGObjectConversion.factor <- function(x) "gchararray"
## RtoGObjectConversion.integer <- function(x) "gint"
## RtoGObjectConversion.numeric <- function(x) "double"
## RtoGObjectConversion.RGtkObject <- function(x) "GObject"
## RtoGObjectConversion.logical <- function(x) "gboolean"

RtoGObjectConversion <- function(x) {
  if(is(x, "factor"))
    "gchararray"
  else if(is(x, "integer"))
    "gint"
  else if(is(x, "numeric"))
    "gdouble"
  else if(is(x, "logical"))
    "gboolean"
  else
    "gchararray"
}




#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/GComponent.R"
##' @include gtk-misc.R
NULL


## Base classes. These are *not* exported, rather each toolkit implementation needs
## to (mostly) provide these same basic classes:
## GComponent
##   - GWidget
##     - GButton
##     - GLabel
##     - Others matching the constructors
##   -GContainer
##     - GWindow
##     - GGroup
##       - GFrame
##         - GExpandGroup
##     - GLayout
##     - GNotebook
##       - GStacked
##     - GPanedGroup



##' Base Class for widgets and containers
##' 
##' GComponent is a parent class for both GContainer and GWidget and
##' inherits its primary interface from
##' gWidgets2::BasicToolkitInterface.
##' @rdname gWidgets2RGtk2-package
##' @export GComponent
GComponent <- setRefClass("GComponent",
                               contains="BasicToolkitInterface",
                               fields=list(
                                 handler_id="ANY",
                                 .e="environment", # for tag
                                 ..invalid="logical",
                                 ..invalid_reason="character",
                                 coerce_with="FunctionOrNULL"
                                 ),
                               methods=list(
                                 initialize=function(toolkit=guiToolkit(), ...,
                                   expand, fill, anchor, label # should be gobbled prior, but don't want to pass on
                                   ) {
                                   initFields(toolkit=toolkit,
                                              .e=new.env()
                                              )
                                   if(is(handler_id, "uninitializedField"))
                                     handler_id <<- NULL

                                   if(is(default_expand, "uninitializedField"))
                                     default_expand <<- NULL

                                   if(is(default_fill, "uninitializedField"))
                                     default_fill <<- NULL

                                   callSuper(...)
                                 },
                                 show = function() {
                                   cat(sprintf("Object of class %s\n", class(.self)[1]))
                                 },
                                 ## length
                                 get_length = function(...) {
                                   "Get length of object. Needed for sapply."
                                   1
                                 },
                                 ## visible
                                 get_visible = function() widget$getVisible(),
                                 set_visible = function(value) widget$setVisible(as.logical(value)),
                                 ## focus
                                 get_focus = function() widget$hasFocus(),
                                 set_focus = function(value) {
                                   "If we can focus, do so, then raise"
                                   if(value) {
                                     if(block$getCanFocus())
                                       block$grabFocus()
                                     block$getWindow()$raise()
                                   }
                                 },
                                 ## enabled 
                                 get_enabled = function() widget$getSensitive(),
                                 set_enabled = function(value) widget$setSensitive(as.logical(value)),
                                 ## tooltip
                                 get_tooltip = function(...) widget$getTooltipText(),
                                 set_tooltip = function(value) widget$setTooltipText(paste(value, collapse="\n")),
                                 ## font
                                 set_font = function(value) {
                                   set_rgtk2_font(getWidget(widget), value)
                                 },
                                 set_rgtk2_font = function(obj, value) {
                                   "Set font on a gtkWidget instance"
                                   if(!is(obj, "GtkWidget"))
                                     stop("Font setting called with object of class", class(obj))
                                   
                                   if(!is.list(value))
                                     value <- sapply(value, identity, simplify=FALSE)
                                   font_desc <- pangoFontDescriptionNew()
                                   for(key in names(value)) {
                                     val <- value[[key]]
                                     switch(key,
                                            "weight"= font_desc$setWeight(PangoWeight[val]),
                                            "style" = font_desc$setStyle(PangoStyle[val]),
                                            "size"  = font_desc$setSize(val * PANGO_SCALE),
                                            "scale" = font_desc$setAbsoluteSize(10 * PangoScale[val] * PANGO_SCALE),
                                            "family" = font_desc$setFamily(val),
                                            "color" = obj$modifyFg(GtkStateType[1], val),
                                            "foreground" = obj$modifyFg(GtkStateType[1], val),
                                            "background" = obj$modifyBg(GtkStateType[1], val),
                                            )
                                   }
                                   obj$modifyFont(font_desc)

                                 },
                                 ## tag
                                 get_attr = function(key) {
                                   if(missing(key))
                                     ls(.e)
                                   else
                                     attr(.e, key)
                                 },
                                 set_attr = function(key, value) {
                                   tmp <- .e
                                   attr(tmp, key) <- value
                                 },
                                 ## still there?
                                 is_extant = function() {
                                   "Is widget still available?"
                                   if(is(block, "<invalid>"))
                                     return(FALSE)
                                   else
                                     TRUE
                                 },
                                 ## size
                                 get_size=function(...) {
                                   alloc <- getBlock(.self)$getAllocation()$allocation
                                   c(width=alloc$width, height=alloc$height)
                                 },
                                 set_size=function(value, ...) {
                                   "Set widget size (size request), value=c(width=-1, height=-1)"
                                   if(is.list(value))
                                     value <- unlist(value) # list is named components
                                   if(length(value) >= 2) {
                                     width <- value[1]; height <- value[2]
                                   } else if(names(value) == "height") {
                                     width <- -1; height <- value
                                   } else {
                                     width <- value; height <- -1
                                   }
                                   getBlock(.self)$SetSizeRequest(width,height)
                                 },
                                 set_invalid=function(value, msg) {
                                   "Set widget as invalid or not"
                                   if(as.logical(value)) {
                                     ..invalid <<- TRUE
                                     ..invalid_reason <<- msg
                                   } else {
                                     ..invalid <<- FALSE
                                     ..invalid_reason <<- ""
                                   }
                                 },
                                 is_invalid=function(...) {
                                   "Is widget in an invalid state"
                                   if(length(..invalid) == 0)
                                     ..invalid <<- FALSE
                                   ..invalid
                                 },
                                 ##
                                 ## Work with containers
                                 ##
                                 set_parent = function(parent) {
                                   "Assign parent to parent property"
                                   parent <<- parent
                                 },
                                 add_to_parent = function(parent, child, expand=NULL, fill=NULL, anchor=NULL, ...) {
                                   "Add a child to parent if it is ia container and non null. Dispatches to add_child method of parent"
                                   
                                   if(missing(parent) || is.null(parent))
                                     return()

                                   ## return here. This is for tcltk compliance
                                   if(is(parent, "GLayout"))
                                     return()
                                   
                                   if(!is(parent, "GContainer") && is.logical(parent) && parent) {
                                     tmp <- gwindow(toolkit=toolkit)
                                     tmp$add_child(child, expand, fill, anchor, ...)
                                     return()
                                   }
                                   if(!is(parent,  "GContainer")) {
                                     message("parent is not a container")
                                     return()
                                   }

                                   parent$add_child(child, expand, fill, anchor, ...)
                                 },
                                 ##
                                 ## Drag and drop
                                 ##
                                 handler_widget = function() widget, # allow override for block (e.g., glabel)
                                 add_drop_source=function(handler, action=NULL, data.type="text", ...) {
                                   "Specify widget is a drag source"
                                  gtkDragSourceSet(handler_widget(),
                                                   start.button.mask=c("button1-mask", "button3-mask"),
                                                   targets=widgetTargetTypes[[data.type]],
                                                   actions="copy")

                                   if(data.type == "text") {
                                     f <- function(h, widget, context, sel, tType, eTime) {
                                       #message("get drag data")
                                       val <- handler(h) # returns text
                                       sel$setText(val, -1) 
                                     }
                                   }
                                   else if(data.type == "object") {
                                     
                                     key <- digest(.self)
                                     f <- function(h, widget, context, sel, tType, eTime) {
                                       #message("get drag data object")                         
                                       val <- handler(h) ## returns an object
                                       .dnd.env[[key]] <- val
                                       sel$setText(key) 
                                     }
                                   }
                                     
                                   
                                   gSignalConnect(handler_widget(), "drag-data-get", f= f,
                                                 data=list(obj=.self, action=action), user.data.first=TRUE)
                                   
                                   if(data.type == "object") {
                                     gSignalConnect(handler_widget(), "drag-end", f=function(key, ...) {
                                       message("drag end")
                                       .dnd.env[[key]] <- NULL # clean up
                                     }, data=digest(.self), user.data.first=TRUE)
                                   }
                                 },
                                 add_drop_target=function(handler, action=NULL, ...) {
                                   "Specify that widget is a drop target"
                                   gtkDragDestSet(handler_widget(),
                                                  flags="all", 
                                                  targets=widgetTargetTypes,
                                                  actions="copy")

                                   gSignalConnect(handler_widget(), "drag-data-received",
                                                  function(h, widget, context, x, y, sel, data.type, event.time) {
                                                   
                                                    ## this call fixed in recent RGtk2 versions so we wrap in try()
                                                    try(gSignalStopEmission(widget, "drag-data-received"), silent=TRUE)
                                                    gtkDragFinish(context, TRUE, FALSE, time=event.time)                                                 
                                                    
                                                    target <- context$getTargets()[[3]] # GdkAtom instance
                                                    target <- attr(target, "name")

                                                    ## do different things depending on context
                                                    if(target == "TEXT") {
                                                      h$dropdata <- rawToChar(sel$getText())
                                                    } else if(as.integer(target) == TARGET.TYPE.TEXT) {
                                                      h$dropdata <- rawToChar(sel$getText())
                                                    } else if(as.integer(target) == TARGET.TYPE.OBJECT) {
                                                      key <- rawToChar(sel$getText())
                                                      h$dropdata <- .dnd.env[[key]]; 
                                                    }
                                                    handler(h)

                                                    
                                                    return(TRUE)
                                                  }, data=list(obj=.self, action=action), user.data.first=TRUE)
                                 },
                                 add_drag_motion=function(handler, action=NULL, ...) {
                                   "Called when motion over widget occurs"
                                   ## avoid add-handler, here we do directly, as above.
                                   gSignalConnect(handler_widget(), "drag-motion", f=function(h, ...) {
                                     handler(h, ...)
                                   }, data=list(obj=.self, action=action), user.data.first=TRUE)
                                 }
                                 
                                 )
                               )

##' GComponentObservable adds the observable interface
##'
##' @param ... passed to constructor
GComponentObservable <- setRefClass("GComponentObservable",
                                    fields=list(
                                      change_signal="character", # what signal is default change signal
                                      connected_signals="list"
                                      ),
                                    contains="GComponent",
                                    methods=list(
                                      ## Some decorators for handlers
                                      ## these wrap the handler to satisfy or fill the h object or return value
                                      event_decorator=function(handler) {
                                        "Decorator for basic event"
                                        force(handler)
                                        f <- function(.self, ...) {
                                          out <- handler(.self, ...)
                                          if(is.atomic(out) && is.logical(out) && out[1])
                                            out[1]
                                          else
                                            FALSE # need logical
                                        }
                                        f
                                      },
                                      key_release_decorator=function(handler) {
                                        force(handler)
                                        f <- function(.self, widget, event,...) {
                                          
                                          key <- event$getString() # XXX This is bad -- no locale, ...
                                          state <- gdkEventKeyGetState(event)
                                          if(state == 0)
                                            modifier <- NULL
                                          else
                                            modifier <- gsub("-mask", "", names(which(state == GdkModifierType)))
                                          handler(.self, key=key, modifier=modifier, state=state, event=event)
                                        }
                                        event_decorator(f)
                                      },
                                      button_press_decorator = function(handler) {
                                        "Add in position information to 'h' component"
                                        force(handler)
                                        f <- function(.self, widget, event, ...) {
                                          ## stuff in some event information
                                          x <- event$getX(); X <- event$getXRoot()
                                          y <- event$getY(); Y <- event$getYRoot()
                                          state <- gsub("-mask", "", names(which(event$getState() == GdkModifierType)))
                                          button <- event$getButton()
                                          handler(.self, x=x,X=X, y=y, Y=Y, state=state, button=button, ...)
                                        }
                                        event_decorator(f)
                                      },
                                      ## code for integrating observable interface with RGtk2
                                      is_handler=function(handler) {
                                        "Helper to see if handler is a handler"
                                        !missing(handler) && !is.null(handler) && is.function(handler)
                                      },
                                      ##
                                      ## Adding a handler means to
                                      ## a) create an observer and add an observer for the given signal
                                      ## 
                                      ## b) create a call back which
                                      ## calls the notify observer
                                      ## method when the widget
                                      ## actualy emits the signal
                                      add_handler=function(signal, handler, action=NULL, decorator, emitter) {
                                        "Uses Observable framework for events. Adds observer, then call connect signal method. Override last if done elsewhere"
                                        if(is_handler(handler)) {
                                          o <- gWidgets2:::observer(.self, handler, action)
                                          invisible(add_observer(o, signal))
                                          connect_to_toolkit_signal(signal, decorator, emitter=emitter)
                                        }
                                      },
                                      add_event_handler=function(handler, action=NULL, ..., decorator) {
                                        add_handler(handler, action=NULL, decorator=.self$event_decorator, ...)
                                      },
                                      

                                      connect_to_toolkit_signal=function(
                                        signal, # which signal (gSignalConnect)
                                        decorator,
                                        emitter=.self$handler_widget() # can override here
                                        ) {
                                        "Connect signal of toolkit to notify observer"
                                        f=function(self, ...) { # notify observer in Gtk callback
                                          self$notify_observers(signal=signal, ...)
                                        }
                                        if(!missing(decorator))
                                          f <- decorator(f)
                                        
                                        ## only connect once
                                        if(is.null(connected_signals[[signal, exact=TRUE]]))
                                          gSignalConnect(handler_widget(), signal, f, data=.self, user.data.first=TRUE)
                                        connected_signals[[signal]] <<- TRUE
                                      },
                                      ## initiate a handler (emit signal)
                                      invoke_handler=function(signal, ...) {
                                        "Bypasses gSignalEmit which crashes R for me.
                                        Invoke observers listening to signal"
                                        notify_observers(..., signal=signal)
                                      },
                                      invoke_change_handler=function(...) {
                                        "Generic change handler invoker."
                                        if(!is(change_signal, "uninitializedField") && length(change_signal))
                                          invoke_handler(signal=change_signal, ...)
                                      },
                                      ## block and unblock
                                      block_handlers=function() {
                                        "Block all handlers."
                                        ## default is to block the observers. 
                                        block_observers()
                                      },
                                      block_handler=function(ID) {
                                        "Block a handler by ID"
                                        block_observer(ID)
                                      },
                                      unblock_handlers=function() {
                                        "unblock blocked observer. May need to be called more than once to clear block"
                                        unblock_observers()
                                      },
                                      unblock_handler=function(ID) {
                                        "unblock a handler by ID"
                                        unblock_observer(ID)
                                      },
                                      remove_handlers=function() {
                                        "Remove all observers"
                                        remove_observers()
                                      }, 
                                      remove_handler=function(ID) {
                                        "remove a handler by ID"
                                        remove_observer(ID)
                                      },
                                      
                                      ## basic set of handlers
                                      add_handler_changed=function(handler, action=NULL,...) {
                                        if(!is(change_signal, "uninitializedField") && length(change_signal)) {
                                          add_handler(change_signal, handler, action, ...)
                                        } else {
                                          stop("No change_signal defined for widget")
                                        }
                                      },
                                      ## Defind add_handler_EVENT methods
                                      ## basically passes down to add_handler or add_event_handler as needed
                                      ## by the RGtk2 event we bind the handler to.
                                      ## we have to check is handler is missing or a function when we apply a decorator
                                      add_handler_keystroke=function(handler, action=NULL, ...) {
                                        "Keystroke handler. Defined for all, but might restrict to only gedit, gtext"
                                        add_handler("key-release-event", handler, action, .self$key_release_decorator, ...)
                                      },                                 
                                      add_handler_clicked = function(handler, action=NULL, ...) {
                                        add_handler("clicked", handler, action, ...)
                                      },
                                      add_handler_button_press=function(handler, action=NULL, ...) {
                                        add_handler("button-press-event", handler, action, .self$button_press_decorator, ...)
                                      },
                                      add_handler_button_release=function(handler, action=NULL, ...) {
                                        add_handler("button-release-event", handler, action, .self$button_press_decorator, ...)
                                      },
                                      add_handler_focus=function(handler, action=NULL, ...) {
                                        add_handler("focus-in-event", handler, action, .self$event_decorator, ...)
                                      },
                                      add_handler_blur=function(handler, action=NULL, ...) {
                                        add_handler("focus-out-event", handler, action, .self$event_decorator, ...)
                                      },
#                                      add_handler_mouse_motion=function(handler, action=NULL, ...) {
#                                        add_handler("motion-notify-event", handler, action, .self$event_decorator, ...)
#                                      },
                                      ## XXX add stibs for others
                                      ##
                                      add_popup_menu = function(menulist, action=NULL, ...) {
                                        if(is(menulist, "list")) 
                                          mb <- gmenu(menulist, popup=TRUE)
                                        else
                                          mb <- menulist
                                        if(!is(mb, "GMenuPopup"))
                                          stop("Pass in popupmenu or list defining one")

                                        f <- function(w, e, ...) {
                                          ## Fixed count in newest RGtk2
                                          if(e$button == 1 && e$type == GdkEventType['button-press']) {
                                            mb$widget$popup(button=e$button, activate.time=e$time)
                                          }
                                          FALSE
                                        }
                                        gSignalConnect(handler_widget(), "button-press-event", f)
                                      },
                                      add_3rd_mouse_popup_menu=function(menulist, action=NULL, ...) {
                                        if(is(menulist, "list")) 
                                          mb <- gmenu(menulist, popup=TRUE)
                                        else
                                          mb <- menulist

                                        if(!is(mb, "GMenuPopup"))
                                          stop("Pass in popupmenu or list defining one")
                                        
                                        f <- function(w, e, ...) {
                                          ## make work wih mac and right mouse!!!
                                          if(isRightMouseClick(e)) {
                                            mb$widget$popup(button=e$button, activate.time=e$time)
                                          }
                                          FALSE
                                        }
                                        gSignalConnect(handler_widget(), "button-press-event", f)
                                      }


                                      ))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/GContainer.R"
##' @include GComponent.R
NULL

##' GContainer is the base class for container objects. The main
##' method is \code{add_child}, but there is also book-keepingn code
##' to keep track of the child components of the container
##' @rdname gWidgets2RGtk2-package
GContainer <- setRefClass("GContainer",
                          contains="GComponentObservable",
                          fields=list(
                            children="list"
                            ),
                          methods=list(
                            add_child = function(child, expand, fill, anchor, ...) {
                              "Add child to parent, do internal book keeping"
                            },
                            child_bookkeeping=function(child) {
                              "Update parent property of child and children property of parent container"
                              if(is(child, "GComponent"))
                                child$set_parent(.self)
                              children <<- c(children, child)
                            },
                            set_child_align=function(child, alt_child, anchor) {
                              "Set child alignment, if a GtkMisc or GtkAlignment object"
                              ## xalign : the horizontal position of the child, 0.0 is left aligned, 1.0 is right aligned
                              ## yalign : the vertical position of the child, 0.0 is top aligned, 1.0 is bottom aligned
                              ## depends on many things.
                              is_candidate <- function(child) is(child,"GtkMisc") || is(child,"GtkAlignment")
                              
                              if(!(is_candidate(child)))
                                child <- alt_child
                              if(is_candidate(child)) {
                                child['xalign'] <- anchor[1]
                                child['yalign'] <- anchor[2]
                              } 
                            },
                            set_child_fill=function(child, fill, horizontal=TRUE) {
                              "Fill can be NULL, TRUE, FALSE, '', 'both', 'x', 'y'..."
                              if(is.null(fill))
                                fill <- FALSE
                              if(is.logical(fill))
                                return(fill)

                              if(is(child, "GtkAlignment")) {
                                if(fill == "both" || fill == "x") {
                                  child['xscale'] <- 1
                                }
                                if(fill == "both" || fill == "y") {
                                  child['yscale'] <- 1
                                }
                                fill <- TRUE
                              }

                              ## else, turn character into logical
                              if(is.character(fill)) {
                                if(fill == "both")
                                  fill <- TRUE
                                else if(fill == "x" && horizontal)
                                  fill <- TRUE
                                else if(fill == "y" && !horizontal)
                                  fill <- TRUE
                                else
                                  fill <- FALSE
                              }
                              return(fill)
                            }
                          ))

                              
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/GWidget.R"
##' @include GComponent.R
NULL

##' GWidget is the Base class for widget objects
##' @rdname gWidgets2RGtk2-package
GWidget <- setRefClass("GWidget",
                       contains="GComponentObservable",
                       methods=list(
                         initialize=function(..., coerce.with=NULL) {
                           if(is.null(coerce_with) && !is.null(coerce.with))
                             coerce_with <<- coerce.with
                           callSuper(...)
                         }
                         )
                       )

                                   
##' GWidgetWithItems is Base class for selection widgets based on a set of items. The key
##' here is the handlers apply to each item, but the handler is
##' assigned to the class member.
##' @rdname gWidgets2RGtk2-package
GWidgetWithItems <- setRefClass("GWidgetWithItems",
                                contains="GWidget",
                                fields=list(
                                  widgets="list"
                                  ),
                                methods=list(
                                  connect_to_toolkit_signal=function(signal,f, emitter) {
                                    ## override, done when adding items
                                  }
                                ))


getWidget.GWidgetWithItems <- function(obj) getWidget(obj$block)


#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/icons.R"
##' @include misc.R
NULL

##' add stock icons
##'
##' @export
##' @inheritParams gWidgets2::addStockIcons
##' @rdname gWidgets2RGtk2-undocumented
##' @method .addStockIcons guiWidgetsToolkitRGtk2
##' @S3method .addStockIcons guiWidgetsToolkitRGtk2
.addStockIcons.guiWidgetsToolkitRGtk2 <- function(toolkit, iconNames, iconFiles,... ) {
  .GWidgetsRGtk2Icons$add_to_gtk_stock_icons(iconNames, iconFiles)
}

##' Returns list of stock ids
##'
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .getStockIcons guiWidgetsToolkitRGtk2
##' @S3method .getStockIcons guiWidgetsToolkitRGtk2
.getStockIcons.guiWidgetsToolkitRGtk2 <- function(toolkit, ...) {
  lst <- gtkStockListIds()
  sapply(unlist(lst), identity, simplify=FALSE)
}

##' return stock id
##'
##' @param name name of icon
##' @export
##' @usage \method{.getStockIconByName}{guiWidgetsToolkitRGtk2}(toolkit,name, ...)
##' @rdname gWidgets2RGtk2-undocumented
##' @method .getStockIconByName guiWidgetsToolkitRGtk2
##' @S3method .getStockIconByName guiWidgetsToolkitRGtk2
.getStockIconByName.guiWidgetsToolkitRGtk2 <- function(toolkit, name, ...) {
  icons <- getStockIcons(toolkit)

  sapply(name, function(icon) {
    tmp <- icons[[icon, exact=TRUE]]
    if(is.null(tmp))
      tmp <- icons[[sprintf("gtk-%s", icon)]]
    if(is.null(tmp))
      tmp <- icons[[sprintf("gw-%s", icon)]]
    if(is.null(tmp))
      tmp <- ""
    tmp
  })
}


##' helper function
##'
##' @export
##' @rdname gWidgets2RGtk2-undocumented
addToGtkStockIcons <- function(iconNames, iconFiles) {

  iconfactory <- gtkIconFactoryNew()
  for(i in seq_along(iconNames)) {
    iconsource <- gtkIconSourceNew()
    iconsource$SetFilename(iconFiles[i])
    
    iconset <- gtkIconSetNew()
    iconset$AddSource(iconsource)
    
    stockName <- paste("gw-", iconNames[i], sep="")
    
    iconfactory$Add(stockName, iconset)
    
    items <- list(test=list(stockName, iconNames[i],"","",""))
    gtkStockAdd(items)
  }
  
  iconfactory$AddDefault()
  invisible(TRUE)
}

GWidgetsRGtk2Icons <- setRefClass("GWidgetsRGtk2Icons",
                                  contains="GWidgets2Icons",
                                  methods=list(
                                    update_icons=function() {
                                      callSuper() # makes icons in icons
                                      add_to_gtk_stock_icons(names(icons), icons)
                                    },
                                    add_to_gtk_stock_icons = function(iconNames, iconFiles) {
                                      iconfactory <- gtkIconFactoryNew()
                                      for(i in seq_along(iconNames)) {
                                        iconsource <- gtkIconSourceNew()
                                        iconsource$SetFilename(iconFiles[i])
                                        
                                        iconset <- gtkIconSetNew()
                                        iconset$AddSource(iconsource)
                                        
                                        stockName <- paste("gw-", iconNames[i], sep="")
                                        
                                        iconfactory$Add(stockName, iconset)
                                        
                                        items <- list(test=list(stockName, iconNames[i],"","",""))
                                        gtkStockAdd(items)
                                      }
                                      
                                      iconfactory$AddDefault()
                                      invisible(TRUE)
                                    }
                                    
                                    ))

.GWidgetsRGtk2Icons <- GWidgetsRGtk2Icons$new()

load_gwidget_icons <- function() {
  ## add the icons
  ## we use xpm icons gimp can convert
  iconFileNames <- list.files(system.file("images", package="gWidgets2"), full.names=TRUE)
  iconFileNames <- Filter(function(x) grepl("\\.gif$", x), iconFileNames)
  iconNames <- basename(iconFileNames)
  iconNames <- gsub("\\.gif$","",iconNames)
  .GWidgetsRGtk2Icons$add_to_gtk_stock_icons(iconNames, iconFileNames)
}

##################################################

##' return stock id from object
##'
##' @param obj R object to get icon from
##' @export
##' @usage \method{.stockIconFromObject}{guiWidgetsToolkitRGtk2}(toolkit,obj, ...)
##' @rdname gWidgets2RGtk2-undocumented
##' @method .stockIconFromObject guiWidgetsToolkitRGtk2
##' @S3method .stockIconFromObject guiWidgetsToolkitRGtk2
.stockIconFromObject.guiWidgetsToolkitRGtk2 <- function(toolkit, obj, ...) {
  icon_for_object <- function(x) UseMethod("icon_for_object")
  icon_for_object.default <- function(x) "gw-symbol_dot"
  icon_for_object.numeric <- function(x) "gtk-numeric"
  icon_for_object.numeric <- function(x) "gw-numeric"
  icon_for_object.factor <- function(x) "gw-factor"
  icon_for_object.character <- function(x) "gw-character"
  icon_for_object.function <- function(x) "fw-function"
  icon_for_object.data.frame <- function(x) "gw-dataframe"
  
  icon_for_object(obj)
}
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/startup.R"
##' @include icons.R
NULL



.onAttach <- function(...) {
  load_gwidget_icons()
}

.onLoad <- function(libname, pkgname) {
  
}
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gbutton.R"
##' @include GWidget.R
NULL


##' toolkit constructor
##' @inheritParams gWidgets2::gbutton
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @seealso The documentation for this is found at \code{\link{gbutton}}.
##' @method .gbutton guiWidgetsToolkitRGtk2
##' @S3method .gbutton guiWidgetsToolkitRGtk2
.gbutton.guiWidgetsToolkitRGtk2 <- function(toolkit, text, handler, action, container, ...) {
  GButton$new(toolkit, text, handler, action, container, ...)
}

##' For RGtk2, the GButton class has the extra reference method
##' \code{set_border}. The \code{border} argument has been deprecated.
##' @rdname gWidgets2RGtk2-package
GButton <- setRefClass("GButton",
                            contains="GWidget",
                            methods=list(
                              initialize=function(toolkit=NULL, text=NULL,  handler, action, container, ...) {
                                
                                widget <<- gtkButton()
                                toolkit <<- toolkit # otherwise next line fails to find toolkit for dispatch
                                if(!is_empty(text))
                                  set_value(text)


                                
                                initFields(block=widget,
                                           change_signal="clicked"
                                           )
                                
                                add_to_parent(container, .self, ...)

                                if(is(action, "GAction")) {
                                  #make_action_proxy(action)
                                  gtkaction <- action$widget
                                  ##
                                  widget$setRelatedAction(gtkaction) # connect
                                  widget$setUseActionAppearance(TRUE)
                                  ##
                                  icon <- gtkaction['stock-id']
                                  if(!is.null(icon)) {
                                    image <- gtkaction$createIcon(GtkIconSize[4]) # button size
                                    widget$setImage(image)
                                    image$show()
                                  }
                                  ## tooltip
                                  tip <- gtkaction['tooltip']
                                  if(!is.null(tip))
                                    tooltip(.self) <- tip
                                } else {
                                  handler_id <<- add_handler_changed(handler, action)
                                }
                                callSuper(toolkit)
                              },
                              set_value=function(value, index=TRUE, drop=TRUE, ...) {
                                old_value <- get_value()
                                if(!is_empty(old_value) && !is_empty(value) &&
                                   value == old_value)
                                  return()
                                set_icon(value)
                                widget$setLabel(value)
                                ## signal change, not done by widget
                                invoke_change_handler()
                              },
                              get_value=function(index=TRUE, drop=TRUE, ...) {
                                widget$getLabel()
                              },
                              set_icon = function(value) {
                                ## Set icon using a stock icon
                                icon <- getStockIconByName(value, toolkit=toolkit)
                                if(!is.null(icon)) {
                                  image <- gtkImageNew()
                                  image$SetFromStock(icon, size="button")
                                  widget$setImage(image)
                                }
                              },
                              set_font = function(value) {
                                object <- getWidget(widget)[[1]] # label is first child or something
                                if(is(object, "GtkAlignment"))
                                  object <- object[[1]][[2]] # a real hacke
                                set_rgtk2_font(object, value)
                              },
                              ## Handler: changed -> clicked
                              add_handler_clicked=function(handler, action=NULL, ...) {
                                add_handler_changed(handler, action, ...)
                              },
                              ## Extra methods
                              remove_border=function() {
                                "Remove border by setting relief to none"
                                widget$SetRelief(GtkReliefStyle['none'])
                              }
                              ))


#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/ggroup.R"
##' @include GContainer.R
NULL

##' toolkit constructor for ggroup
##'
##' @inheritParams gWidgets2::ggroup
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .ggroup guiWidgetsToolkitRGtk2
##' @S3method .ggroup guiWidgetsToolkitRGtk2
.ggroup.guiWidgetsToolkitRGtk2 <- function(toolkit, horizontal=TRUE, spacing=5, use.scrollwindow=FALSE, container=NULL, ...) {
  GGroup$new(toolkit, horizontal, spacing=spacing, use.scrollwindow=use.scrollwindow, container, ...)
}

## TODO XXX raise on drag motion

GGroupBase <- setRefClass("GGroupBase",
                      contains="GContainer",
                      fields=list(
                        horizontal="logical"
                        ),
                          ## Make a widget, for subclassing

                          methods=list(
                            make_widget=function(...) {},
                        
                        ## Main add method
                        add_child = function(child, expand, fill, anchor, ...) {
                        "Add child to box container. Child can be RGtk2object or GComponent. We use expand=TRUE, fill=TRUE as a default for containers, and expand=FALSE, fill=FALSE, as the default for widgets. These will usually need tweeking. The properties default_expand and default_fill allow for this."
                        toolkit_child <- getBlock(child)
                        
                        theArgs <- list(...) ## padding (around each)
                        
                        ## anchor puts in one of 9 spots
                        ## if expand=FALSE, fill meaningless
                        ## if expand=TRUE, then
                        ## * anchor=NULL, fill=[TRUE (both), "x", or "y"] to fill in dirction x, y or both
                        
                        
                        ## get expand, anchor, fill
                        expand <- getWithDefault(expand, getWithDefault(child$default_expand, FALSE))

                        ## anchor
                        if(!is.null(theArgs$align))
                          theArgs$anchor <- theArgs$align
                        anchor <- getWithDefault(anchor, NULL)
                        
                        if(!is.null(anchor)) {       # put in [0,1]^2
                          anchor <- (anchor+1)/2      # [0,1]
                          anchor[2] <- 1 - anchor[2]     # flip yalign
                          set_child_align(toolkit_child, getWidget(child), anchor)
                        }

                        
                        ## fill one of NULL, TRUE, FALSE, "", both, "x", "y"
                        if(expand) {
                          fill <- getWithDefault(fill, getWithDefault(child$default_fill, ifelse(is.null(anchor),"both", "")))
                          fill <- set_child_fill(toolkit_child, fill, horizontal)
                        }

                        padding <- getWithDefault(theArgs$padding, 0L)
                        
                        ## all done
                        widget$packStart(toolkit_child, expand=expand, fill=fill, padding=padding)
                        child_bookkeeping(child)
                      },
                        
                        
                        ## Remove a child from list. Can be added back in, if not garbage collected
                        remove_child = function(child) {
                          "remove child from box container"
                          children <<- Filter(function(x) !identical(x, child), children) # remove from list
                          child$set_parent(NULL) # adjust child widget property
                          widget$remove(getBlock(child)) # GUI removal happens last
                        },
                        add_spring=function() {
                          widget$PackStart(gtkHBoxNew(),TRUE,TRUE,0)
                        },
                        add_space=function(value) {
                          box <- gtkHBox()
                          if(horizontal)
                            box$setSizeRequest(value, -1L)
                          else
                            box$setSizeRequest(-1L, value)
                          widget$PackStart(gtkHBoxNew(),FALSE, FALSE,0)
                        },
                        ## [ for returning children
                        get_items = function(i, j, ..., drop=TRUE) {
                          "Return children"
                          out <- children[i]
                          if(drop && length(out) == 1)
                            out[[1]]
                          else
                            out
                        },

                        ## svalue spacing (not borderWidth
                        get_value=function(...) {
                          widget$getSpacing()
                        },
                            set_value=function(value, ...) {
                              widget$setSpacing(as.numeric(value)[1])
                            },
                            set_borderwidth=function(value, ...) {
                              "Sets borderwidth -- space around frame of container. not spacing between children"
                              widget$setBorderWidth(as.numeric(value)[1])
                            },


                        ## size
                        ## get_size=function() {
                        ##   getBlock(widget)$sizeRequest()
                        ## },
                        set_size=function(value) {
                          tmp <- getBlock(widget) # size of block, if scrolled window
                          value <- as.integer(value)
                          tmp$setSizeRequest(value[1], value[2])
                        }


                        
                        ))

                              

## base class for box containers. 
GGroup <- setRefClass("GGroup",
                      contains="GGroupBase",
                      methods=list(
                        ## main intialize method
                        initialize=function(toolkit=NULL,
                          horizontal=TRUE, spacing=5,
                          use.scrollwindow=FALSE,
                          container=NULL, ...) {
                          
                          horizontal <<- horizontal
                          ## To be able to subclass we define widget in separate method
                          if(is(widget, "uninitializedField")) 
                            make_widget(use.scrollwindow, spacing)
                          
                          add_to_parent(container, .self, ...)
                          
                          callSuper(toolkit)
                        },
                        make_widget = function(use.scrollwindow, spacing) {
                               if(horizontal)
                                 widget <<- gtkHBox(homogeneous=FALSE, spacing=spacing)
                               else
                                 widget <<- gtkVBox(homogeneous=FALSE, spacing=spacing)

                               set_value(spacing)

                               use.scrollwindow <- as.character(use.scrollwindow)
                               
                               if(use.scrollwindow != "FALSE") {
                                 block <<- gtkScrolledWindowNew()
                                 if(use.scrollwindow == "x")
                                   block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_NEVER")
                                 else if(use.scrollwindow == "y")
                                   block$SetPolicy("GTK_POLICY_NEVER","GTK_POLICY_AUTOMATIC")
                                 else
                                   block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                                 block$AddWithViewport(widget)
                               } else {
                                 block <<- widget
                               }
                             }            
                        ))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gframe.R"
##' @include ggroup.R
NULL

##' gframe constructor
##'
##' @inheritParams gWidgets2::gframe
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gframe guiWidgetsToolkitRGtk2
##' @S3method .gframe guiWidgetsToolkitRGtk2
.gframe.guiWidgetsToolkitRGtk2 <- function(toolkit, text, markup, pos, horizontal=TRUE, spacing=5,container=NULL, ...) {
  GFrame$new(toolkit, text, markup, pos, horizontal, spacing, container, ...)
}

## base class for gframe
GFrame <- setRefClass("GFrame",
                      contains="GGroupBase",
                      fields=list(
                        markup="logical",
                        spacing="numeric"
                        ),
                      methods=list(
                        initialize=function(toolkit=NULL, text="", markup=FALSE, pos=0, horizontal=TRUE, spacing=5, container=NULL,
                          ...) {

                          horizontal <<- horizontal
                          spacing <<- spacing
                          make_widget(text, markup, pos)
                          
                          add_to_parent(container, .self, ...)
                          
                          callSuper(toolkit, horizontal=horizontal, ...)
                        },
                        make_widget = function(text, markup, pos) {
                          if(horizontal)
                            widget <<- gtkHBox()
                          else
                            widget <<- gtkVBox()
                          
                          markup <<- markup

                          block <<- gtkFrameNew()
                          block$SetLabelAlign(pos,0.5)
                          label <- gtkLabelNew()
                          block$setLabelWidget(label)
                          set_names(text)
                          block$add(widget)
                        },
                        get_names=function(...) {
                          label <- block$getLabelWidget()
                          label$getLabel()
                        },
                        set_names=function(value, ...) {
                          label <- block$getLabelWidget()
                          if(markup)
                            label$setMarkup(value)
                          else
                            label$setLabel(value)
                        }
                        ))
                        
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gexpandgroup.R"
##' @include gframe.R
NULL

##' toolkit constructor
##'
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gexpandgroup guiWidgetsToolkitRGtk2
##' @S3method .gexpandgroup guiWidgetsToolkitRGtk2
.gexpandgroup.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                                 text, markup,  horizontal=TRUE,
                                                 handler=NULL, action=NULL,
                                                 container=NULL, ...) {
  GExpandGroup$new(toolkit, text=text, markup=markup, horizontal=horizontal, handler=handler, action=action, container=container, ...)
}

## base class from gframe
GExpandGroup <- setRefClass("GExpandGroup",
                            contains="GGroupBase",
                            fields=list(
                              "markup"="logical"
                              ),
                            methods=list(
                              initialize=function(toolkit=NULL, text, markup=FALSE, horizontal=TRUE, handler, action, container=NULL, ..., expand=FALSE, fill=FALSE) {

                                horizontal <<- horizontal
                                if(is(widget, "uninitializedField")) 
                                  make_widget(text, markup)
                                
                                handler_id <<- add_handler_changed(handler, action)
                                add_to_parent(container, .self, expand, fill, ...)
                                
                                callSuper(toolkit, horizontal=horizontal, ...)
                              },
                              make_widget = function(text, markup) {
                                if(horizontal)
                                  widget <<- gtkHBox()
                                else
                                  widget <<- gtkVBox()
                                
                                markup <<- markup
                                block <<- gtkExpanderNew()
                                if(markup)
                                  block$setUseMarkup(TRUE)
                                block$add(widget)
                                
                                set_names(text)
                              },
                              get_names=function(...) {
                                block$getLabel()
                              },
                              set_names=function(value, ...) {
                                block$setLabel(value)
                              },
                              get_visible = function() {
                                block$getExpanded()
                              },
                              set_visible = function(value) {
                                block$setExpanded(as.logical(value))
                              },
                              set_font = function(value) {
                                label <- block[[2]] # dig it out!
                                 set_rgtk2_font(label, value)
                              },
                              add_handler_changed=function(handler, action, ...) {
                                add_handler("activate", handler, action, ...)
                              }
                              ))
                            
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gcheckbox.R"
##' @include GWidget.R
NULL

##' Toolkit XXX constructor
##'
##' @inheritParams gWidgets2::gcheckbox
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gcheckbox guiWidgetsToolkitRGtk2
##' @S3method .gcheckbox guiWidgetsToolkitRGtk2
.gcheckbox.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                              text, checked = FALSE, use.togglebutton=FALSE, handler = NULL, action = NULL,
                                              container = NULL, ... ) {
  if(use.togglebutton)
    GToggleButton$new(toolkit,
                      text, checked, handler, action, container, ...)
  else
    GCheckbox$new(toolkit,
                  text, checked, handler, action, container, ...)
}

## Checkbox reference class
GCheckbox <- setRefClass("GCheckbox",
                         contains="GWidget",
                         methods=list(
                           initialize=function(toolkit=NULL,
                             text="", checked = FALSE,  handler = NULL, action = NULL,
                             container = NULL, ... ) {
                             
                             widget <<- gtkCheckButtonNewWithLabel(text)
                             widget$setActive(checked)
                             
                             initFields(block=widget,
                                        change_signal="toggled"
                                        )
                             add_to_parent(container, .self, ...)
                             
                             handler_id <<- add_handler_changed(handler, action)
                             
                             callSuper(toolkit)
                           },
                           set_value=function(value, index=TRUE, drop=TRUE, ...) {
                             widget$setActive(value)
                             ## invoke_change_handler() # not needed?
                           },
                           get_value=function(index=TRUE, drop=TRUE, ...) {
                             widget$getActive()
                           },
                           get_items = function(i, j, ..., drop=TRUE) {
                             widget[[1]]$getLabel()
                           },
                           set_items = function(value, i, j, ...) {
                             widget[[1]]$setLabel(value)
                           },
                           set_font = function(value) {
                             ## need to set font on label
                             label_widget <- getWidget(widget)$getChildren()[[1]]
                             set_rgtk2_font(label_widget, value)
                           }
                           ## ,
                           ## add_handler_changed=function(handler, action=NULL, ...) {
                           ##   add_handler("toggled", handler, action=action, ...)
                           ## }
                           ))


## Basic toggle button class
GToggleButton <- setRefClass("GToggleButton",
                             contains="GCheckbox",
                             methods=list(
                               initialize=function(toolkit=NULL,
                                 text, checked = FALSE,  handler = NULL, action = NULL,
                                 container = NULL, ... ) {

                                 widget <<- gtkToggleButtonNewWithLabel(text)
                                 set_items(value=text)

                                 set_value(checked)
                                 
                                 initFields(
                                            block=widget,
                                            change_signal="toggled"
                                           )
                                 
                                 add_to_parent(container, .self, ...)
                                 
                                 handler_id <<- add_handler_changed(handler, action)
                                 
                                 callSuper(toolkit)
                              },
                              get_items = function(i, j, ..., drop=TRUE) {
                                widget$getLabel()
                              },
                              set_items = function(value, i, j, ...) {
                                ## use UseStock if in stock icon
                                widget$setLabel(value)
                              }
                              ##  ,
                              ## add_handler_changed=function(handler, action=NULL, ...) {
                              ##   add_handler("toggled", handler, action=action, ...)
                              ## }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gcheckboxgroup.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gcheckboxgroup
##' @export
##' @usage  \method{.gcheckboxgroup}{guiWidgetsToolkitRGtk2}(toolkit=NULL, items, checked = FALSE, horizontal = FALSE, use.table = FALSE, handler = NULL, action = NULL, container = NULL, ...)
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gcheckboxgroup guiWidgetsToolkitRGtk2
##' @S3method .gcheckboxgroup guiWidgetsToolkitRGtk2
.gcheckboxgroup.guiWidgetsToolkitRGtk2 <-  function(toolkit=NULL,
                                                    items, checked = FALSE, horizontal = FALSE,
                                                    use.table=FALSE, handler = NULL,
                                                    action = NULL, container = NULL, ... ) {
  if(use.table)
    GCheckboxGroupTable$new(toolkit, items, checked = checked,
                            handler = handler,action = action,  container = container, ...)
  else
    GCheckboxGroup$new(toolkit,
                       items, checked = checked, horizontal = horizontal,
                       handler = handler, action = action, container = container, ...)
}


## checkbox group class
GCheckboxGroup <- setRefClass("GCheckboxGroup",
                            contains="GWidgetWithItems",
                            methods=list(
                              initialize=function(toolkit,
                                items, checked = FALSE, horizontal = FALSE,
                                 handler = NULL,
                                action = NULL, container = NULL, ... ) {

                                if(horizontal)
                                  block <<- gtkHBox()
                                else
                                  block <<- gtkVBox()
                                widget <<- NULL

                                initFields(widgets = list(),
                                           change_signal="toggled"
                                           )


                                set_items(value=items)
                                set_index(checked)
                                add_to_parent(container, .self, ...)

                                handler_id <<- add_handler_changed(handler, action)

                                callSuper(toolkit)
                              },
                              get_value=function(drop=TRUE, ...) {
                                items <- get_items()
                                items[get_index()]
                              },
                              set_value=function(value, drop=TRUE, ...) {
                                ## value may be logical
                                items <- get_items()
                                if(is.logical(value) && !is.logical(items)) {
                                  set_index(value)
                                } else {
                                  ind <- pmatch(value, items)
                                  set_index(ind)                                
                                }
                              },
                              get_index = function(...) {
                                "Return indices, not logical"
                                which(sapply(widgets, function(i) i$getActive()))
                              },
                              set_index=function(value, ...) {
                                block_observer()
                                if(is.logical(value))
                                  value <- rep(value, length=get_length())
                                if(is.numeric(value)) {
                                  value <- is.element(seq_len(get_length()), value)
                                }
                                mapply(gtkToggleButtonSetActive, object=widgets, is.active=value)
                                unblock_observer()
                                notify_observers(signal="toggled")
                                invisible()
                              },
                              get_items = function(i, ...) {
                                items <- sapply(widgets, function(i) i[[1]]$getLabel())[i]
                                setNames(items, NULL) # drop names
                              },
                              set_items = function(value, i, ...) {
                                ## make widgets
                                widgets <<- sapply(value, gtkCheckButtonNewWithLabel)
                                ## layout widgets
                                sapply(block$getChildren(), gtkContainerRemove, object=block) # remove old
                                sapply(widgets, gtkBoxPackStart, object=block, expand=FALSE, padding=1)
                                ## connec widgets
                                sapply(widgets, gSignalConnect, signal="toggled", f=function(self, widget, event, ...) {
                                  self$notify_observers(signal="toggled", ...)
                                }, data=.self, user.data.first=TRUE)
                                invisible()
                              },
                              get_length = function() {
                                length(widgets)
                              }
                              ))


## uses table for checkboxes
GCheckboxGroupTable <-  setRefClass("GCheckboxGroupTable",
                            contains="GWidget",
                            methods=list(
                              initialize=function(toolkit,
                                items, checked = FALSE,
                                handler = NULL,
                                action = NULL, container = NULL, ... ) {

                                widget <<- gtkTreeViewNew(TRUE)
                                widget$SetRulesHint(TRUE)      # shade

                                block <<- gtkScrolledWindowNew()
                                block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                                block$Add(widget)
                                
                                store <- rGtkDataFrame(make_items())
                                widget$setModel(store)
                                widget$setHeadersVisible(FALSE)
                                
                                ## set up the view columns
                                vc <- gtkTreeViewColumnNew()
                                widget$insertColumn(vc, 0)
                                cr <- gtkCellRendererToggle()
                                vc$PackStart(cr, TRUE)
                                cr['activatable'] <- TRUE                  # needed
                                vc$addAttribute(cr, "active", 1)            
                                item.toggled <- function(tbl, cell, path, data) {
                                  store <- tbl$getModel()
                                  row <- as.numeric(path) + 1
                                  store[row,2] <- !store[row, 2]
                                }
                                gSignalConnect(cr, "toggled", item.toggled, data=widget, user.data.first=TRUE)

                                cr <- gtkCellRendererTextNew()
                                vc <- gtkTreeViewColumnNew()
                                vc$PackStart(cr, TRUE)
                                vc$addAttribute(cr, "text", 0)            
                                widget$insertColumn(vc, 1)

                                ## icons, tooltips???
                                initFields(change_signal="toggled")
                                set_items(value=items)
                                set_index(checked)
                                
                                add_to_parent(container, .self, ...)

                                handler_id <<- add_handler_changed(handler, action)

                                callSuper(toolkit)
                              },
                              ## helper function
                              make_items = function(items, icons, tooltips, checked=rep(FALSE, length(items))) {
                                if(missing(items) ||
                                   (is.data.frame(items) && nrow(items) == 0) ||
                                   (length(items) == 0)
                                   ) {
                                  out <- data.frame(items=character(0),
                                                    checked=logical(0),
                                                    icons=character(0),
                                                    tooltips=character(0),
                                                    stringsAsFactors=FALSE)
                                } else if(is.data.frame(items)) {
                                  ## check
                                  out <- items
                                  if(ncol(out) == 1) 
                                    out$checked <- as.logical(rep(checked, length=nrow(items)))
                                  if(ncol(out) == 2)
                                    out$icons <- rep("", nrow(items))
                                  if(ncol(out) == 3)
                                    out$tooltip <- rep("", nrow(items))
                                } else {
                                  ## piece together
                                  items <- as.character(items)
                                  
                                  if(missing(icons))
                                    icons <- ""
                                  icons <- rep(icons, length=length(items))
                                  
                                  if(missing(tooltips))
                                    tooltips <- ""
                                  icons <- rep(tooltips, length=length(items))
                                  
                                  checked <- rep(checked, length=length(items))
                                  
                                  out <- data.frame(items=items, checked=checked, icons=icons, tooltips=tooltips,
                                                    stringsAsFactors=FALSE)
                                }
                                return(out)
                              },
                              get_value=function(drop=TRUE, ...) {
                                get_items(get_index())
                              },
                              set_value=function(value,  drop=TRUE, ...) {
                                ind <- match(value, get_items())
                                ind <- ind[!is.na(ind)]
                                set_index(ind)
                              },
                              get_index = function(...) {
                                store <- widget$getModel()
                                vals <- store[,2, drop=TRUE]
                                which(vals)
                              },
                              set_index=function(value, ...) {
                                if(is.numeric(value)) {
                                  value <- is.element(seq_len(get_length()), value)
                                }
                                store <- widget$getModel()
                                store[,2] <- value

                                invoke_change_handler()
                                ## how to get view of model to update? (toggle signal of cell renderer?)
                              },
                              get_items = function(i, ...) {
                                store <- widget$getModel()
                                items <- store[,1, drop=TRUE]
                                items[i]
                              },
                              set_items = function(value, i, ...) {
                                items <- make_items(value)

                                if(missing(i)) {
                                  ## replace the store
                                  newStore <- rGtkDataFrame(items)
                                  widget$setModel(newStore)
                                } else {
                                  if(is.logical(i))
                                    i <- which(i)
                                  
                                  store[i,] <- items
                                }
                                invoke_change_handler()
                              },
                              get_length = function() {
                                "Number of items to choose from"
                                length(get_items())
                              },
                              ## handlers
                              handler_widget=function() {
                                ## put handler on cell renderer, not widget
                                view_column <- widget$getColumn(0)
                                cell_renderer <- view_column$getCellRenderers()[[1]]
                                cell_renderer
                              }
                              ))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gcombobox.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gcombobox
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gcombobox guiWidgetsToolkitRGtk2
##' @S3method .gcombobox guiWidgetsToolkitRGtk2
.gcombobox.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                               items, selected = 1, editable = FALSE, coerce.with = NULL,
                                               handler = NULL,action = NULL, container = NULL, ... ) {

  if(editable)
    GComboBoxWithEntry$new(toolkit,
                           items, selected = selected, coerce.with = coerce.with,
                           handler = handler,action = action, container = container, ...)
  else
    GComboBoxNoEntry$new(toolkit,
                         items, selected = selected, coerce.with = coerce.with,
                         handler = handler,action = action, container = container, ...)
  
}


## We create two subclasses of this to handle editable and
## non-editable situation. These methods end up being in common for
## both.
GComboBox <- setRefClass("GComboBox",
                         contains="GWidget",
                         methods=list(
                           get_index = function(...) {
                             widget$getActive() + 1L
                           },
                           set_index = function(value,...) {
                             value <- min(max(-1, as.integer(value)), get_length())
                             widget$setActive(value - 1L)
                           },
                           ## ,
                           ## add_handler_changed=function(handler, action=NULL, ...) {
                           ##   add_handler_clicked(handler, action=NULL, ...)
                           ## },
                           add_handler_clicked = function(handler, action=NULL, ...) {
                             add_handler("changed", handler, action=action, ...)
                           },
                           check_windows = function(items) {
                             "Hack to make width under windows work better"
                             if(.Platform$OS == "windows") {
                               if(dim(items)[1] > 0) {
                                 n_char <- function(x) nchar(as.character(x))
                                 colChars <- max(sapply(items[,1,drop=TRUE],n_char))
                                 if(colChars < 3)
                                   widget$setSizeRequest(15*(4 + colChars), -1L)
                               }
                             }
                           }
                           ))

## combobox without entry can have icons, use rGtkDataFrame
GComboBoxNoEntry <- setRefClass("GComboBoxNoEntry",
                                contains="GComboBox",
                                methods=list(
                                  initialize=function(toolkit=NULL,
                                    items,
                                    selected = 1, # use 0 for blank
                                    coerce.with = NULL,
                                    handler, action, container, ...) {

                                    if(ncol(items) >=2)
                                      items[[2]] <- sapply(items[[2]], getStockIconByName)
                                    
                                    store <- rGtkDataFrame(items)
                                    ## drop down list, not combo
                                    widget <<- gtkComboBoxNewWithModel(store)
                                    cellrenderer <- gtkCellRendererTextNew()
                                    cellrenderer['ellipsize'] <- PangoEllipsizeMode[3]
                                    widget$PackStart(cellrenderer, expand=TRUE)
                                    
                                    widget$AddAttribute(cellrenderer,"text", 0)
                                    ## icons
                                    if(ncol(items) >= 2) {
                                      cellrenderer <- gtkCellRendererPixbufNew()
                                      widget$PackStart(cellrenderer, expand=FALSE)
                                      widget$AddAttribute(cellrenderer, "stock-id", 1)
                                      
                                      if(ncol(items) >= 3) {
                                        message("tooltips are not implemented for gcombobox and gWidgets2RGtk2")
                                      }
                                    }
                                    
                                    widget$show()
                                    widget$setActive(selected - 1L)
                                    
                                    check_windows(items)
                                    
                                    initFields(block=widget,
                                               coerce_with=coerce.with,
                                               change_signal="changed",
                                               ..blocked=0L
                                               )
                                    
                                    add_to_parent(container, .self, ...)
                                    
                                    handler_id <<- add_handler_changed(handler, action)
                                    
                                    callSuper(toolkit)
                                  },
                                  get_value=function( ...) {
                                    widget$getModel()[get_index(), 1]
                                  },
                                  set_value=function(value, ...) {
                                    ind <- pmatch(value, get_items(drop=TRUE))
                                    if(!is.na(ind))
                                      set_index(ind)
                                    else
                                      message("No match for ", value)
                                  },
                                  get_items = function(i, j, ..., drop=TRUE) {
                                    store <- widget$getModel()
                                    if(drop)
                                      store[i,1, drop=TRUE]
                                    else
                                      store[i,]
                                  },
                                  set_items = function(value, i, j, ...) {
                                    "Set items. Indexing is ignored"
                                    items <- gWidgets2:::.make_gcombobox_items(value)
                                    store <- rGtkDataFrame(items)
                                    if(ncol(store) != ncol(widget$getModel()))
                                      stop("Must keep same number of columns when replacing values")
                                    widget$setModel(store)
                                    set_index(0L)
                                  },
                                  get_length = function(...) {
                                    nrow(widget$getModel())
                                  }
                                  ))

## The editable code is *different* from the non-editable code, as the
## gtkComboBoxNewWithEntry method isn't there yet. Instead we need to
## use a convenience function and manipulate the values with that.
## This method is deprecated as of 2.24, but that isn't what I have
## installed
## we intercept the argument use_completion=TRUE to add completion to entry
GComboBoxWithEntry <- setRefClass("GComboBoxWithEntry",
                                contains="GComboBox",
                                  fields=list(
                                    poss_items="ANY"
                                    ),
                                  methods=list(
                                    initialize=function(toolkit=NULL,
                                      items,
                                      selected = 1, # use 0 for blank
                                      coerce.with = NULL,
                                      handler, action, container, ...) {
                                      
                                      poss_items <<- items[,1, drop=TRUE]

                                      widget <<- gtkComboBoxEntryNewText()
                                      sapply(poss_items, gtkComboBoxAppendText, object=widget)

                                      widget$show()
                                      widget$setActive(selected - 1L)

                                      ## set size if really small under windows
                                      check_windows(items)

                                      initFields(block=widget,
                                                 coerce_with=coerce.with,
                                                 change_signal="changed"
                                                 )

                                      if(getWithDefault(list(...)[["use_completion"]], FALSE))
                                        use_completion()
                                      
                                      add_to_parent(container, .self, ...)

                                      handler_id <<- add_handler_changed(handler, action)

                                      callSuper(toolkit)
                                    },
                                    get_value=function( ...) {
                                      widget$getChild()$getText()
                                    },
                                    set_value=function(value, ...) {
                                      widget$getChild()$setText(value)
                                    },
                                    get_items = function(i, j, ..., drop=TRUE) {
                                      poss_items
                                    },
                                    set_items = function(value, i, j, ...) {
                                      "Set items. Indexing is ignored"
                                      ## remove, then append
                                      sapply(rev(seq_len(get_length())), function(i) widget$removeText(i - 1L))
                                      items <- value[,1, drop=TRUE]
                                      sapply(items, gtkComboBoxAppendText, object=widget)
                                      poss_items <<- items
                                      block_handlers()
                                      set_value("")
                                      unblock_handlers()
                                    },
                                    get_length = function(...) {
                                      widget$getModel()$iterNChildren(NULL)
                                    },
                                    use_completion=function(...) {
                                      "put completion code onto combo"
                                      completion <- gtkEntryCompletionNew()
                                      completion$SetModel(widget$getModel()) # reuse model

                                      ## customize
                                      completion$SetTextColumn(0)           # Columns count from 0 -- not 1
                                      completion$setInlineCompletion(TRUE)
                                      completion$setInlineSelection(TRUE)

                                      entry <- widget$getChildren()[[1]] # HACKY!!
                                      entry$SetCompletion(completion)
                                      ## add search/clear icon
                                      entry$setIconFromStock("primary", getStockIconByName("ed-search"))
                                      where <- "secondary"
                                      entry$setIconFromStock(where, getStockIconByName("ed-remove"))
                                      entry$setIconActivatable(where, TRUE)
                                      gSignalConnect(entry, "icon-press", function(e, ...) e$setText(""))
                                    },
                                    add_handler_edited = function(handler, action=NULL, ...) {
                                      "For editing -- need a better name XXX"
                                      gSignalConnect(widget$getChild(), "activate", f=function(h, ...) {
                                        handler(h, ...)
                                      },  data=list(obj=obj, action=action,...),
                                                     user.data.first = TRUE)
                                    },
                                    add_handler_keystroke=function(handler, action=NULL, ...) {
                                      gSignalConnect(widget$getChild(), "keystroke", .$self$key_release_decorator(handler),
                                                     data=list(obj=obj, action=action,...),
                                                     user.data.first = TRUE)
                                    }
                                    
                                    ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gnotebook.R"
##' @include GContainer.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gnotebook
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gnotebook guiWidgetsToolkitRGtk2
##' @S3method .gnotebook guiWidgetsToolkitRGtk2
.gnotebook.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                               tab.pos = 3, 
                                               container = NULL, ... ) {
  GNotebook$new(toolkit, tab.pos, 
                    container = container, ...)
}



GNotebook <- setRefClass("GNotebook",
                            contains="GContainer",
                            methods=list(
                              initialize=function(toolkit=NULL, tab.pos=3, 
                                 container=NULL, ...) {
                                
                                ## To be able to subclass we define widget in separate method
                                if(is(widget, "uninitializedField")) 
                                  make_widget(tab.pos)

                                add_to_parent(container, .self, ...)

                                callSuper(toolkit)
                              },
                              make_widget = function(tab.pos) {
                                widget <<- gtkNotebookNew()
                                widget$SetScrollable(TRUE)
                                
            
                                ## tab placement: 1,2,3,4 -> 3,0,2,1
                                types <- c("bottom","left","top","right")
                                tabposition <- GtkPositionType[types]
                                widget$SetTabPos(tabposition[tab.pos])
                                
                                
                                initFields(block=widget)
                              }, 
                              get_value=function( ...) {
                                widget$getCurrentPage() + 1L
                              },
                              set_value=function(value, ...) {
                                nPages <- widget$GetNPages()
                                widget$SetCurrentPage(min(nPages,as.numeric(value)-1))
                              },
                              get_index = function(...) {
                                get_value()
                              },
                              set_index = function(value,...) {
                                set_value(value)
                              },
                              get_names = function(...) {
                                n <- widget$getNPages()
                                if(n == 0)
                                  return(character(0))
                                sapply(seq_len(n), function(i) {
                                  label <- widget$getTabLabel(getBlock(get_items(i, drop=TRUE)))
                                  label[[1]]$getText()
                                })
                              },
                              set_names = function(value, ...) {
                                n <- widget$getNPages()
                                sapply(seq_len(n), function(i) {
                                  label <- widget$getTabLabel(getBlock(get_items(i, drop=TRUE)))
                                  label[[1]]$setText(value[i])
                                })
                                invisible()
                              },
                              get_items = function(i, j, ..., drop=TRUE) {
                                "Return child at ith spot"
                                items <- children[i]
                                if(drop && length(items) == 1)
                                  items[[1]]
                                else
                                  items
                              },
                              get_length = function(...) {
                                "Nmber of pages"
                                widget$GetNPages()
                              },
                              ##
                              make_label = function(child, label, close.button=FALSE, ...) {
                                ## make a label widget, possibly with close buttons, ...
                                hbox <- gtkHBox()
                                l <- gtkLabel(label)
                                hbox$packStart(l, expand=TRUE, fill=TRUE)
                                if(!is.null(close.button) && close.button) {
                                  evb <- gtkEventBox()
                                  evb$setVisibleWindow(FALSE)
                                  hbox$packEnd(evb)
                                  img <- gtkImageNew()
                                  img$setFromStock("gtk-close", size=GtkIconSize['small-toolbar'])
                                  evb$add(img)
                                  gSignalConnect(evb, "button-press-event", f=function(data, ...) {
                                    data$widget$remove_child(data$child)
                                  }, data=list(widget=.self, child=child), user.data.first=TRUE)
                                }
                                hbox
                              },
                              add_child=function(child, label="", index=NULL, close.button=FALSE, ...) {
                                label_widget <- make_label(child, label, close.button, ...) ## XXX
                                
                                if(is.null(index) || !is.numeric(index))
                                  page_no <- widget$appendPage(getBlock(child), label_widget)
                                else if(index < 1)
                                  page_no <- widget$prependPage(getBlock(child), label_widget)
                                else
                                  page_no <- widget$insertPage(getBlock(child), label_widget, position=index-1L)
                                set_value(page_no + 1)

                                child_bookkeeping(child)
                                
                              },
                              remove_child = function(child) {
                                ## remove from children
                                children <<- Filter(function(i) !identical(i, child), children)
                                ## remove from widget
                                widget$remove(getBlock(child))
                              },
                              remove_page_by_index=function(i) {
                                child <- get_items(i)
                                remove_child(child)
                              },
                              remove_current_page = function() {
                                remove_page_by_index(get_index())
                              },
                              ## handlers
                              add_handler_changed=function(handler, action=NULL, ...) {
                                "A tab changed"
                                decorator <- function(FUN) {
                                  force(FUN)
                                  f <- function(self, w, pageref, i, ...) {
                                    FUN(self, page.no= i + 1L)
                                  }
                                  f
                                }
                                add_handler("switch-page", handler, action=action, decorator=decorator, ...)
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gpanedgroup.R"
##' @include GContainer.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gpanedgroup
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gpanedgroup guiWidgetsToolkitRGtk2
##' @S3method .gpanedgroup guiWidgetsToolkitRGtk2
.gpanedgroup.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                horizontal = TRUE, 
                                                container = NULL, ... ) {
  GPanedGroup$new(toolkit,
           horizontal=horizontal, 
           container = container, ...)
}


## main class
GPanedGroup <- setRefClass("GPanedGroup",
                            contains="GContainer",
                           fields=list(
                             horizontal="logical"
                             ),
                            methods=list(
                              initialize=function(toolkit=NULL,
                                horizontal=TRUE,
                                container=NULL, ...) {
                                if(horizontal)
                                  widget <<- gtkHPanedNew()
                                else
                                  widget <<- gtkVPanedNew()


                                initFields(block=widget,
                                           horizontal=horizontal
                                           )
                                add_to_parent(container, .self, ...)
                                callSuper(toolkit)
                              },
                              get_value = function(...) {
                                "get sash position"
                                pos <- widget$getPosition()
                                sz <- get_size()

                                if(horizontal)
                                  pos/sz[1]
                                else
                                  pos/sz[2]
                              }, 
                              set_value = function(value, ...) {
                                "Set sash position"
                                if(is.integer(value)) {
                                  pos <- value
                                } else {
                                  sz <- get_size()

                                  if(horizontal)
                                    pos <- as.integer(value*sz[1])
                                  else
                                    pos <- as.integer(value*sz[2])
                                }
                                widget$setPosition(pos)
                              },
                              get_items = function(i, j, ..., drop=TRUE) {
                                children[[i, drop=drop]]
                              },
                              get_length = function() {
                                length(children)
                              },
                              add_child=function(child, expand=NULL, fill=NULL, anchor=NULL, resize=TRUE, shrink=FALSE) {
                                "Add one of two possible children"
                                n <- get_length()
                                if(n >= 2) {
                                  message("Already have two children. Remove one?")
                                  return()
                                }
                                
                                if(n == 0) {
                                  widget$pack1(getBlock(child), resize=resize, shrink=shrink)
                                } else if(n == 1) {
                                  widget$pack2(getBlock(child), resize, shrink)
                                }

                                child_bookkeeping(child)
                              },
                              remove_child=function(child) {
                                "remove child from paned container"
                                children <<- Filter(function(x) !identical(x, child), children)
                                child$set_parent(NULL)
                                widget$remove(getBlock(child))
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gseparator.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::ggroup
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gseparator guiWidgetsToolkitRGtk2
##' @S3method .gseparator guiWidgetsToolkitRGtk2
.gseparator.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                         horizontal = TRUE,
                   container = NULL, ... ) {
  GSeparator$new(toolkit, horizontal=horizontal, container = container, ...)
}


GSeparator <- setRefClass("GSeparator",
                          contains="GWidget",
                          methods=list(
                            initialize=function(toolkit,
                              horizontal=TRUE, container=NULL,
                              ...) {
                              
                              if(horizontal)
                                widget <<- gtkHSeparatorNew()
                              else
                                widget <<- gtkVSeparatorNew()
                              
                              initFields(block=widget)
                              add_to_parent(container, .self, ...)
                              
                              callSuper(toolkit)
                            }
                            ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gstackwidget.R"
##' @include gnotebook.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gnotebook
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gstackwidget guiWidgetsToolkitRGtk2
##' @S3method .gstackwidget guiWidgetsToolkitRGtk2
.gstackwidget.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                  container = NULL, ... ) {
  GStackWidget$new(toolkit,
                   container = container, ...)
}



GStackWidget <- setRefClass("GStackWidget",
                            contains="GNotebook",
                            methods=list(
                              initialize=function(toolkit=NULL,
                                 container=NULL, ...) {

                                ## To be able to subclass we define widget in separate method
                                if(is(widget, "uninitializedField")) 
                                  make_widget()

                                add_to_parent(container, .self, ...)

                                callSuper(toolkit, container=container)
                              },
                              make_widget = function() {
                                widget <<- gtkNotebookNew()
                                widget$setShowTabs(FALSE)
                                initFields(block=widget)
                              },
                              get_names=function(...) {},
                              set_names=function(...) {},
                              add_child=function(child,  index=NULL,  ...) {
                                "Similar to GNotebook's, but without label and close button code"
                                
                                if(is.null(index))
                                  page_no <- widget$appendPage(getBlock(child))
                                else if(index < 1)
                                  page_no <- widget$prependPage(getBlock(child))
                                else
                                  page_no <- widget$insertPage(getBlock(child), position=index-1L)
                                set_value(page_no + 1L)

                                child_bookkeeping(child)
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gwindow.R"
##' @include GContainer.R
NULL

##' toolkit constructor for gwindow
##'
##' @inheritParams gWidgets2::gwindow
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gwindow guiWidgetsToolkitRGtk2
##' @S3method .gwindow guiWidgetsToolkitRGtk2
.gwindow.guiWidgetsToolkitRGtk2 <- function(toolkit, title, visible=visible, name, width, height, parent, handler, action,  ...) {
  GWindow$new(toolkit, title, visible=visible, name, width, height, parent, handler, action,  ...)
}

## Main class for gwindow instances
GWindow <- setRefClass("GWindow",
                            contains="GContainer",
                            fields=list(
                              menubar_area="ANY",
                              toolbar_area="ANY",
                              infobar_area="ANY",
                              content_area="ANY",
                              statusbar_area="ANY",
                              statusbar_widget="ANY"
                              ),
                            methods=list(
                              initialize=function(toolkit=NULL, title="",  visible=TRUE, name=NULL, width=NULL, height=NULL,
                                parent=NULL, handler, action, ...) {

                                widget <<- gtkWindow(show=FALSE)
                                set_value(title)
                                if(is.null(width))
                                  width <- 400L
                                if(is.null(height))
                                  height <- as.integer(0.7 * width)
                                widget$setDefaultSize(width, height)


                                if(!is.null(parent)) {
                                  if(inherits(parent, "GComponent")) {
                                    ## a widget
                                    parent_widget <- getWidget(parent)
                                    if(!inherits(parent_widget,"GtkWindow"))
                                      parent_widget <- getGtkWindow(parent_widget)
                                    widget$setTransientFor(parent_widget)
                                    widget$setPosition(GtkWindowPosition["center-on-parent"])
                                    widget$setDestroyWithParent(TRUE)
                                    ## windows fixes
                                    widget$setSkipTaskbarHint(TRUE)
                                    widget$setSkipPagerHint(TRUE)
                                  } else {
                                    ## check that parent is a numeric pair
                                    if(is.numeric(parent) && length(parent) >= 2) {
                                      widget$Move(as.integer(parent[1]),as.integer(parent[2]))
                                    }
                                  }
                                }

                                
                                initFields(toolkit=toolkit, block=NULL,
                                           menubar_area=gtkHBox(),
                                           toolbar_area=gtkHBox(),
                                           infobar_area=gtkInfoBar(show=FALSE),
                                           content_area=gtkHBox(),
                                           statusbar_area=gtkHBox()
                                           )
                                init_infobar()
                                
                                ## add areas to widget. For now we have simple
                                layout_widget()
                                
                                handler_id <<- add_handler_changed(handler, action)

                                if(visible)
                                  widget$show()
                                
                                callSuper(...)
                              },
                              layout_widget = function() {
                                ## we make a stack of widgets, content_area is the key one
                                tbl <- gtkTable(rows=4, columns=1, homogeneous=FALSE)
                                tbl$SetColSpacings(0)
                                tbl$SetRowSpacings(0)
                                tbl$Attach(menubar_area, 0,1,0,1, xoptions=c("expand", "fill"), yoptions = c("shrink"))
                                tbl$Attach(toolbar_area, 0,1,1,2,  xoptions=c("expand", "fill"), yoptions = c("shrink"))
                                tbl$Attach(infobar_area, 0,1,2,3, xoptions=c("expand", "fill"), yoptions = c("shrink"))
                                tbl$Attach(content_area, 0,1,3,4, xoptions=c("expand", "fill"), yoptions=c("expand", "fill"))
                                tbl$Attach(statusbar_area, 0,1,4,5, xoptions=c("expand", "fill"), yoptions = c("shrink"))
                                
                                ## size grip issue if no statusbar
                                ##content_area['border-width'] <<- 13
                                ## XXX status bar is too short for labels

                                widget$add(tbl)
                              },
                              init_infobar=function() {
                                infobar_area$setNoShowAll(TRUE)
                                infobar_area$setMessageType("warning")            
                                infobar_area$addButton(button.text = "gtk-ok",
                                                   response.id = GtkResponseType['ok'])
                                gSignalConnect(infobar_area, "response", 
                                               function(infobar_area, resp.id) infobar_area$hide())
                                gSignalConnect(infobar_area, "response", 
                                               function(infobar_area, resp.id) infobar_area$hide())
                              },
                              ## Widget methods
                              get_value = function(...) widget$getTitle(),
                              set_value = function(value, ...) widget$setTitle(paste(value, collapse=" ")),
                              set_focus = function(value) {
                                if(value)
                                  widget$present()
                              },
                              get_size = function() {
                                theSize <- widget$GetSize()
                                return(unlist(theSize[2:3]))
                              },
                              update_widget=function(...) {
                                widget$setSizeRequest(-1, -1)
                              },
                              is_extant=function() {
                                !is(widget, "<invalid>")
                              },
                              set_icon=function(stock) {
                                if(file.exists(stock))
                                  iconfile <- stock
                                else
                                  iconfile <- .GWidgetsRGtk2Icons$icons[[stock]]
                                if(!is.null(iconfile))
                                  widget$setIconFromFile(iconfile)
                              },
                              ##
                              ## add methods
                              add_child=function(child, ...) {
                                                                
                                if(missing(child) || is.null(child))
                                  return()

                                ## whoa nelly, must check on type of child here -- not just in add method
                                if(is(child, "GMenuBar")) {
                                  add_menubar(child)
                                } else if(is(child, "GToolBar")) {
                                  add_toolbar(child)
                                } else if(is(child, "GStatusBar")) {
                                  add_statusbar(child)
                                } else {
                                  ## clear out old (only one child allowed)
                                  sapply(content_area$getChildren(), content_area$remove)
                                  ## add. Child can be RGtk2Object or GComponent
                                  content_area$packStart(getBlock(child), expand=TRUE, fill=TRUE)
                                }
                                child_bookkeeping(child)
                              },
                              remove_child=function(child) {
                                child$set_parent(NULL)
                                content_area$remove(getBlock(child))
                              },
                              dispose_window = function() {
                                "close window"
                                widget$destroy()
                              },
                              add_menubar=function(child, ...) {
                                menubar_area$packStart(getBlock(child), expand=TRUE, fill=TRUE)
                              },
                              add_toolbar=function(child, ...) {
                                toolbar_area$packStart(getBlock(child), expand=TRUE, fill=TRUE)
                              },
                              add_statusbar=function(child, ...) {
                                statusbar_widget <<- child # RGtk2 object
                                statusbar_area$packStart(getBlock(child), expand=TRUE, fill=TRUE)
                              },
                              ## set infobar message
                              set_infobar=function(msg, ...) {
                                label <- gtkLabel(msg)
                                curChildren <- infobar_area$getContentArea()$getChildren()
                                if(length(curChildren))
                                  sapply(curChildren, infobar_area$getContentArea()$remove)
                                infobar_area$getContentArea()$packStart(label, expand=TRUE, fill=TRUE)
                                infobar_area$show()
                                ## hide after 4 seconds of mouse click
                                timer <- gtimer(4*1000, FUN=function(...) {
                                  if(is_extant())
                                    infobar_area$hide()
                                }, one.shot=TRUE, toolkit=toolkit)
                              },
                              ## set statusbar message
                              set_statusbar=function(msg, ...) {
                                if(!is(statusbar_widget, "uninitializedField"))
                                  statusbar_widget$set_value(msg)
                              },
                              ## clear statusbar message
                              clear_statusbar=function(...) {
                                if(!is(statusbar_widget, "uninitializedField"))
                                  statusbar_widget$set_value("")
                              },

                              ## handlers
                              add_handler_changed=function(handler, action=NULL, ...) {
                                add_handler_destroy(handler, action, ...)
                              },
                              add_handler_destroy=function(handler, action=NULL, ...) {
                                "window manager delete event"
                                add_handler("destroy", handler, action=action, ...)
                              },
                              add_handler_unrealize=function(handler, action, ...) {
                                "Intercept window manager delete event"
                                add_event_handler("delete-event", handler, action=action, ...)
                              }
                              ))


                              
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gmenu.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gmenu
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gmenu guiWidgetsToolkitRGtk2
##' @S3method .gmenu guiWidgetsToolkitRGtk2
.gmenu.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                           menu.list=list(),
                                           popup=FALSE,
                                           container = NULL,
                                           ... ) {
  if(popup)
    GMenuPopup$new(toolkit, menu.list=menu.list,  ...)
  else
    GMenuBar$new(toolkit, menu.list=menu.list, container = container, ...)
}


## Toplevel menu bar
GMenuBar <- setRefClass("GMenuBar",
                     contains="GWidget",
                     fields=list(
                       menu_list="list"
                       ),
                     methods=list(
                       initialize=function(toolkit=NULL,
                         menu.list=list(),
                         container=NULL, ...) {

                         if(is(widget, "uninitializedField")) {
                           widget <<- gtkMenuBarNew()
                           initFields(block=widget)
                           
                           menu_list <<- list()
                           set_value(menu.list)
                           add_to_parent(container, .self, ...)
                         }
                         callSuper(toolkit)
                       },
                       ## add items
                       add_menu_items=function(sub_menu, items) {
                         sapply(items, function(item) {
                           ## do dispatch based on class
                           if(is(item, "list")) {
                             ## get name by looking up and matching
                             add_submenu(sub_menu, item, nm=names(Filter(function(x) identical(x, item), items)))
                           } else if(is(item, "GAction")) {
                             add_gaction_menuitem(sub_menu, item)
                           } else if(is(item, "GSeparator")) {
                             add_gseparator_menuitem(sub_menu, item)
                           } else if(is(item, "GRadio")) {
                             add_radio_menuitem(sub_menu, item)
                           } else if(is(item, "GCheckbox")) {
                             add_checkbutton_menuitem(sub_menu, item)
                           } else {
                             add_widget_menuitem(sub_menu, item)
                           }
                         })
                         sub_menu$show()
                       },
                       add_submenu=function(sub_menu, items, nm) {
                         item <- gtkMenuItem(nm)
                         sub_menu$append(item)
                         sub_menu <- gtkMenu()
                         add_menu_items(sub_menu, items)
                         item$setSubmenu(sub_menu)
                       },
                       add_gaction_menuitem=function(sub_menu, item) {
                         action <- item$widget
                         item <- gtkImageMenuItem("")
                         if("always-show-image" %in% names(item))
                           item['always-show-image'] <- TRUE
                         sub_menu$append(item)
                         item$setRelatedAction(action)
                       },
                       add_gseparator_menuitem=function(sub_menu, item) {
                         item <- gtkSeparatorMenuItem()
                         sub_menu$append(item)
                       },
                       add_radio_menuitem=function(sub_menu, item) {
                         rb <- item
                         cur <- svalue(rb, index=TRUE)
                         nms <- rb[]
                         ## do this the *hard* way using check menu items, simple way failed
                         ## as I didn't know how to start gtkRadioMenuItem group off.
                         rbs <- sapply(nms, function(i) {
                           item <- gtkCheckMenuItemNewWithLabel(i)
                           item$setDrawAsRadio(TRUE)
                           sub_menu$append(item)
                           item
                         })
                         rbs[[cur]]$setActive(TRUE)
                         sapply(rbs, gSignalConnect, signal="toggled", f=function(w, ...) {
                           if(w$getActive()) {
                             ind <- sapply(rbs, identical, w)
                             sapply(which(!ind), function(i) rbs[[i]]$setActive(FALSE))
                             svalue(rb, index=TRUE) <- which(ind)
                           }
                         })
                       },
                       add_checkbutton_menuitem=function(sub_menu, item) {
                         cb <- item
                         item <- gtkCheckMenuItemNewWithLabel(cb[1])
                         item$setActive(svalue(cb))
                         gSignalConnect(item, "toggled", function(w, ...) {
                           cur <- w$getActive()
                           svalue(cb) <- cur
                         })
                         sub_menu$append(item)
                       },
                       add_widget_menuitem=function(sub_menu, item) {
                         "Add an arbitrary widget, though likely not a good thing to do."
                         mitem <- gtkMenuItemNew()
                         mitem$add(getBlock(item))
                         sub_menu$append(mitem)
                       },
                       clear_menubar=function() {
                         "Clear out menu items"
                         sapply(rev(widget$getChildren()), widget$remove)
                         widget$hide()
                       },
                       ##
                       get_value=function( ...) {
                         menu_list
                       },
                       set_value=function(value, ...) {
                         clear_menubar()
                         menu_list <<- value
                         add_menu_items(widget, value)
                         widget$show()
                       },
                       append_value=function(items) {
                         "Append to menu list"
                         menu_list <<- gWidgets2:::merge.list(menu_list, items)
                         add_menu_items(widget, items)
                       }
                       ))


## Popup class
GMenuPopup <- setRefClass("GMenuPopup",
                            contains="GMenuBar",
                            methods=list(
                              initialize=function(toolkit=NULL,
                                menu.list=list(),
                                ...) {
                                widget <<- gtkMenuNew()
                                initFields(block=widget)
                                menu_list <<- menu.list
                                add_menu_items(widget, menu.list)
                                callSuper(toolkit)
                              }
                              ))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gstatusbar.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::glabel
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gstatusbar guiWidgetsToolkitRGtk2
##' @S3method .gstatusbar guiWidgetsToolkitRGtk2
.gstatusbar.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                text="",
                                                container = NULL, ... ) {
  GStatusBar$new(toolkit,
                 text=text,
                 container = container, ...)
}


GStatusBar <- setRefClass("GStatusBar",
                          contains="GWidget",
                          methods=list(
                            initialize=function(toolkit=NULL,
                              text="", container=NULL, ...) {
                              
                              block <<- gtkStatusbarNew()
                              block$setHasResizeGrip(TRUE)
                              sbl <- block[[1]][[1]]
                              ## use our own label, not statusbars
                              label <- widget <<- gtkLabel()
                              label['xalign'] <- 0.0
                              block[[1]]$remove(block[[1]][[1]])
                              block[[1]]$add(widget)

                              set_value(text)

                              if(!is.null(container))
                                if(!is(container, "GWindow"))
                                  getTopLevel(container)$add_statusbar(.self)
                                else
                                  container$add_statusbar(.self)

                              callSuper(toolkit)
                              },
                              get_value=function( ...) {
                                widget$getLabel()
                              },
                              set_value=function(value, ...) {
                                widget$setLabel(paste(value, collapse=";"))
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtoolbar.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gtoolbar
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gtoolbar guiWidgetsToolkitRGtk2
##' @S3method .gtoolbar guiWidgetsToolkitRGtk2
.gtoolbar.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                              toolbar.list=list(),
                                              style = c("both","icons","text","both-horiz"),
                                              container = NULL,
                                              ... ) {
  GToolBar$new(toolkit,
               toolbar.list=toolbar.list, style=style,
               container=container ,...)
}


## toolbar class
GToolBar <- setRefClass("GToolBar",
                        contains="GWidget",
                        fields=list(
                          toolbar_list="list"
                          ),
                        methods=list(
                          initialize=function(toolkit=NULL,
                            toolbar.list=list(),
                            style = c("both", "icons", "text", "both-horiz"),
                            container = NULL,
                            ...) {
                            
                            widget <<- gtkToolbar()
                            widget$setStyle(match.arg(style))
                            
                            initFields(block=widget,
                                       toolbar_list=list()
                                       )

                            add_toolbar_items(toolbar.list)

                            if(!is.null(container) && is(container, "GWindow"))
                              add_to_parent(container, .self, ...)
                            
                            callSuper(toolkit)
                          },
                          add_toolbar_items=function(items) {
                            "Map a toolbar list, a named list of gaction items or gsepartor items"
                            ## XXX Odd, doesn't seem to like this style -- doesn't find dispatcher.GAction
                            ## dispatcher <- function(item) UseMethod("dispatcher")
                            ## dispatcher.default <- function(item) add_widget_toolitem(item)
                            ## dispatcher.GAction <- function(item) add_gaction_toolitem(item)
                            ## dispatcher.GSeparator <- function(item) add_gseparator_toolitem(item)
                            ## sapply(items, dispatcher)
                            sapply(items, function(item) {
                              ## do dispatch based on class
                              if(is(item, "GAction"))
                                add_gaction_toolitem(item)
                              else if(is(item, "GSeparator"))
                                add_gseparator_toolitem(item)
                              else
                                add_widget_toolitem(item)
                            })
                            widget$show()
                            toolbar_list <<- gWidgets2:::merge.list(toolbar_list, items)
                          },
                          add_gseparator_toolitem=function(obj) {
                            "Helper to add a separator"
                            item <- gtkSeparatorToolItemNew()
                            widget$insert(item, pos=-1)
                          },
                          add_gaction_toolitem=function(obj) {
                            "Helper to add a gaction item"
                            item <- obj$widget$createToolItem()
                            widget$insert(item, pos=-1)
                          },
                          add_widget_toolitem=function(obj) {
                            "Add a widget to the toolbar"
                            item <- gtkToolItemNew()
                            item$add(getBlock(obj))
                            widget$insert(item, pos=-1)
                          },
                          clear_toolbar=function() {
                            "Clear toolbar items"
                            x <- widget$getChildren()
                            sapply(rev(x), widget$remove)
                            widget$hide()
                          },
                          get_value=function( ...) {
                            toolbar_list
                          },
                          set_value=function(value, ...) {
                            "Clear toolbar, add anew"
                            clear_toolbar()
                            add_toolbar_items(value)
                          }
                          ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gslider.R"
##' @include GWidget.R
NULL

##' Toolkit  constructor
##'
##' @inheritParams gWidgets2::gslider
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gslider guiWidgetsToolkitRGtk2
##' @S3method .gslider guiWidgetsToolkitRGtk2
.gslider.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                             from = 0, to = 100, by = 1, value = from, horizontal = TRUE,
                                             handler = NULL, action = NULL, container = NULL, ... ) {
  GSlider$new(toolkit,
              from, to, by, value, horizontal,
              handler,action, container, ...)
}


## glider class
GSlider <- setRefClass("GSlider",
                       contains="GWidget",
                       fields=list(
                         items = "ANY"
                         ),
                       methods=list(
                         initialize=function(toolkit,
                           from, to, by, value, horizontal,
                           handler, action, container, ...) {
                           if(length(from) == 1)
                             x <- seq(from, to, by)
                           else
                             x <- from
                           x <- sort(unique(x))
                           items <<- x
                           
                           if (horizontal)
                             widget <<- gtkHScaleNewWithRange(1L, length(items), 1L)
                           else
                             widget <<- gtkVScaleNewWithRange(1L, length(items), 1L)

                           gSignalConnect(widget, "format-value", function(widget, value, ...) {
                             ## value is index
                             format(items[as.integer(value)], digits=3)
                           })
                           set_value(value[1])
                           
                           initFields(block=widget,
                                      default_expand=TRUE,
                                      default_fill=ifelse(horizontal, "x", "y"),
                                      change_signal="value-changed")
                           
                           add_to_parent(container, .self, ...)

                           handler_id <<- add_handler_changed(handler, action)
                           
                           callSuper(toolkit)
                         },
                         get_value=function(drop=TRUE, ...) {
                           items[get_index()]
                         },
                         set_value=function(value, drop=TRUE, ...) {
                           i <- pmatch(value, items)
                           set_index(i)
                         },
                         get_index = function(...) {
                           widget$getValue()
                         },
                         set_index = function(value,...) {
                           if(!is_empty(value))
                             widget$setValue(value) # widget uses index 1, ..., n
                         },
                         get_items = function(i, ...) {
                           items
                         },
                         set_items = function(value, i, ...) {
                           cur <- get_value()
                           items <<- sort(unique(value))
                           widget$setRange(1, length(value))
                           widget$setIncrements(1L, 1L) # button 1, button 2
                           
                           set_value(cur)
                         }
                         ## ,
                         ## add_handler_changed=function(handler, action=NULL, ...) {
                         ##   add_handler("value-changed", handler, action=action, ...)
                         ## }
                         ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gspinbutton.R"
##' @include GWidget.R
NULL

##' Toolkit XXX constructor
##'
##' @param digits digits
##' @inheritParams gWidgets2::gslider
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gspinbutton guiWidgetsToolkitRGtk2
##' @S3method .gspinbutton guiWidgetsToolkitRGtk2
.gspinbutton.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                 from = 0, to = 10, by = 1, value = from, digits = 0,
                                                 handler = NULL,action = NULL, container = NULL, ... ) {
  GSpinButton$new( toolkit, from , to , by, value, digits,
                  handler = handler, action = action, container = container, ...)
}


## spingbutton class
GSpinButton <- setRefClass("GSpinButton",
                            contains="GWidget",
                            methods=list(
                              initialize=function(toolkit,
                                from = 0, to = 10, by = 1, value = from, digits = 0,
                                handler, action, container, ...) {

                                if(digits == 0 &&  as.logical((by %% 1))) # FALSE if integer o/w T
                                  digits <- abs(floor(log(by,10)))
             
                                adjustment <- gtkAdjustmentNew(value=value, lower=from,
                                                               upper=to,step.incr=by)
                                widget <<- gtkSpinButtonNew(adjustment, (to-from)/by, digits=digits)
                                set_value(value)
                                
                                initFields(block=widget,
                                           change_signal="value-changed"
                                           )

                                add_to_parent(container, .self, ...)

                                handler_id <<- add_handler_changed(handler, action)

                                callSuper(toolkit)
                              },
                              get_value=function(drop=TRUE, ...) {
                                widget$getValue()
                              },
                              set_value=function(value, drop=TRUE, ...) {
                                widget$setValue(value)
                              },
                              set_items = function(value, i, ...) {
                                ## check that value is a regular sequence
                                if(length(value) <=1) {
                                  message("Can only assign a vector with equal steps, as produced by seq, say")
                                  return()
                                }
                                if(length(value) > 2 &&
                                   !all.equal(diff(diff(value)), rep(0, length(value) - 2))) {
                                  message("Can only assign a vector with equal steps, as produced by seq, say")
                                  return()
                                }
                                ## get current value, increment
                                cur <- get_value()
                                inc <- head(diff(value), n=1)

                                widget$setRange(min(value), max(value))
                                widget$setIncrements(inc, inc) # button 1, button 2
                                set_value(cur)
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/glayout.R"
##' @include GContainer.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::glayout
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .glayout guiWidgetsToolkitRGtk2
##' @S3method .glayout guiWidgetsToolkitRGtk2
.glayout.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                             homogeneous = FALSE, spacing = 10,
                                             container = NULL, ... ) {
  GLayout$new(toolkit=toolkit, homogeneous=homogeneous, spacing=spacing, container = container, ...)
}


## layout class
GLayout <- setRefClass("GLayout",
                       contains="GContainer",
                       fields=list(
                         child_positions="list"
                         ),
                       methods=list(
                         initialize=function(toolkit=NULL,
                           homogeneous = FALSE, spacing = 10,
                           container = NULL, ... 
                           ) {
                           
                           widget <<- gtkTableNew(homogeneous = homogeneous)
                           ## homogeneous spacing
                           widget$SetRowSpacings(spacing)
                           widget$SetColSpacings(spacing)
                           
                           initFields(block=widget,
                                      child_positions=list()
                                      )
                           
                           add_to_parent(container, .self, ...)

                           callSuper(toolkit)
                         },
                         get_dim=function(...) {
                           "current size of table"
                           c(nrow=widget$getNrows(), ncol=widget$getNcols())
                         },
                         get_items = function(i, j, ..., drop=TRUE) {
                           ## make matrix, then extract
                           d <- get_dim()
                           m <- matrix(nrow=d[1], ncol=d[2])
                           for(index in seq_along(child_positions)) {
                             item <- child_positions[[index]] 
                             for(ii in item$x)
                               for(jj in item$y) {
                                 m[ii,jj] <- index
                               }
                           }
                           widgets <- sapply(as.vector(m), function(ii) {
                             if(is.na(ii))
                               NA
                             else
                               child_positions[[ii]]$child
                           })
                           widgets <- matrix(widgets, ncol=d[2])
                           out <- widgets[i,j, drop=drop]
                           if(length(out) == 1 && drop)
                             out <- out[[1]]
                           out
                         },
                         set_items = function(value, i, j, expand=FALSE, fill=FALSE, anchor=NULL) {
                           "Main method to add children"

                           if(missing(j)) {
                             cat(gettext("glayout: [ needs to have a column specified."))
                             return()
                           }

                           if(missing(i))
                             i <- get_dim()[1] + 1
                           
                           if(is.character(value)) {
                             value <- glabel(value, toolkit=toolkit)
                           }

                           expand <- getWithDefault(expand, getWithDefault(child$default_expand, FALSE))
                           fill <- getWithDefault(fill, getWithDefault(child$default_fill, FALSE))
                           
                           ## widgets
                           child <- getBlock(value)
                           
                           
                           if(!is.null(anchor)) {       # put in [0,1]^2
                             anchor <- (anchor+1)/2      # [0,1]
                             anchor[2] <- 1 - anchor[2]     # flip yalign
                           }

                           if(expand) {
                             set_child_align(child, getWidget(value), anchor)
                           }
                           
                           ## we do things differently if there is a gtkAlignment for a block
                           if(is(child, "GtkAlignment")) {
                             if(expand && (fill == TRUE || fill =="both" || fill == "x")) {
                               child['xscale'] <- 1
                             }

                             if(expand && (fill== TRUE || fill == "both" || fill == "y")) {
                               child['yscale'] <- 1
                             }
                             
                             if(expand && fill == "") {
                               child['xscale'] <- child['yscale'] <- 1
                             }
                           } 
                           
                           ## resize table widget if needed
                           d <- get_dim()
                           nr <- max(i); nc <- max(j)
                           if( nr > d[1] || nc > d[2])
                             widget$Resize(max(max(i), nr), max(max(j), nc))

                           ## fill options
                           xopts <- yopts <- "fill"
                           if(expand) {
                             if(is.null(fill) ||
                                (is.character(fill) && fill == "both")
                               ) {
                               xopts <- yopts <- c("fill","expand","shrink")
                             } else if(is.character(fill) && fill == "x") {
                               xopts <-  c("fill","expand","shrink")
                             } else if(is.character(fill) && fill == "y") {
                               yopts <-  c("fill","expand","shrink")
                             }
                           }  
                           
                           widget$Attach(child,
                                         min(j)-1, max(j), min(i)-1, max(i),
                                         xoptions=xopts, yoptions=yopts)

                             
                           ## Internal bookkeeping, add to lists
                           if(is(value, "GComponent"))
                             value$set_parent(.self)
                           children <<- c(children, value)
                           ## store for [ method
                           l <- child_positions
#                           l[[as.character(length(l) + 1)]] <- list(x=i, y=j, child=value)
                           l[[length(l) + 1]] <- list(x=i, y=j, child=value)
                           child_positions <<- l
                         },
                         remove_child=function(child) {
                           if(!is(child, "GComponent"))
                             return()
                           ## we call destroy method on child -- not being reused
                           ## remove from child_positions
                           child_positions <<- Filter(Negate(function(i) {
                             i$child$widget == child$widget
                           }), child_positions)
                           children <<- Filter(function(i) !identical(i, child), children)
                           getBlock(child)$destroy()
                         }
                         ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gradio.R"
##' @include GWidget.R
NULL

##' Toolkit  constructor
##'
##' @inheritParams gWidgets2::gradio
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gradio guiWidgetsToolkitRGtk2
##' @S3method .gradio guiWidgetsToolkitRGtk2
.gradio.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                            items,selected=1, horizontal=FALSE, handler=NULL,
                                            action=NULL, container=NULL, ...
                                            ) {

  GRadio$new(toolkit, items, selected, horizontal,
             handler, action, container, ...)
}


## radio button class
GRadio <- setRefClass("GRadio",
                      contains="GWidgetWithItems",
                      methods=list(
                        initialize=function(toolkit, items, selected, horizontal,
                          handler, action, container, ...) {
                          widget <<- NULL
                          widgets <<- list()
                          if(horizontal)
                            block <<- gtkHBox()
                          else
                            block <<- gtkVBox()

                          change_signal <<- "toggled"
                          
                          set_items(value=items)
                          set_index(selected)
                          
                          add_to_parent(container, .self, ...)
                          
                          handler_id <<- add_handler_changed(handler, action)
                          
                          callSuper(toolkit)
                        },
                        get_value=function(drop=TRUE, ...) {
                          get_items(get_index())
                        },
                        set_value=function(value, drop=TRUE, ...) {
                          set_index(pmatch(value, get_items()))
                        },
                        get_index = function(...) {
                          which(sapply(widgets, gtkToggleButtonGetActive))
                        },
                        set_index = function(value, ...) {
                          widgets[[value[1]]]$setActive(TRUE)
                        },
                        get_items = function(i, ...) {
                          items <- sapply(widgets, gtkButtonGetLabel)
                          items[i]
                        },
                        set_items = function(value, i, ...) {
                          ## make widgets
                          radiogp <- gtkRadioButton(label=value[1])
                          sapply(value[-1], gtkRadioButtonNewWithLabelFromWidget, 
                                      group = radiogp)
                          widgets <<- rev(radiogp$getGroup())
                          ## pack in widgets
                          sapply(block$getChildren(), gtkContainerRemove, object=block) # remove old
                          sapply(widgets, gtkBoxPackStart, object=block, padding=2)
                          
                          ## add handler to each button to call back to observers
                          sapply(widgets, gSignalConnect, signal="toggled", f = function(self, w, ...) {
                            if(w$getActive())
                              self$notify_observers(signal="toggled", ...)
                          }, data=.self, user.data.first=TRUE)
                          invisible()
                        },
                        get_length=function(...) length(get_items()),
                        get_enabled=function() {block$getSensitive()},
                        set_enabled=function(value) {block$setSensitive(value)},
                        get_visible = function() block$getVisible(),
                        set_visible = function(value) block$setVisible(as.logical(value))
                        ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/dialogs.R"
##' @include GWidget.R
NULL

## Base class for dialogs
##
## Override modify_widget, ok_response, cancel_response and get_buttons
GDialog <- setRefClass("GDialog",
                      contains="GContainer",
                      methods=list(
                        initialize=function(toolkit=NULL, msg="", title="", icon="info", parent=NULL, ...) {
                          
                          icon <- paste("GTK_MESSAGE_",toupper(icon), sep="")
    
                          ## parent is for placement, not tracking widget heirarchy
                          .parent <- parent
                          if(!is.null(.parent)) {
                            if(is(.parent, "GWindow"))
                              .parent <- .parent
                            .parent <- getBlock(.parent)
                            if(!is(.parent,"GtkWindow"))
                              .parent <- .parent$GetWindow()
                            if(!is(.parent,"GtkWindow"))
                              .parent <- NULL          # give up
                          }
  
                            
                          ## use message dialog for Gtk
                          widget <<- gtkMessageDialogNew(
                                                         parent = .parent,
                                                         flags = 0,
                                                         buttons = get_buttons(),
                                                         type=icon,
                                                         msg[1]
                                                         )
                          ## odd, should have show=FALSE above, but doesn't work. Not sure why. Error is:
                          ## > dlg = GDialog$new(NULL, msg="asdf")
                          ## Error in .Object$initialize(...) : attempt to apply non-function
                          ## > traceback()
                          ## 5: .Object$initialize(...)
                          ## 4: initialize(value, ...)
                          ## 3: initialize(value, ...)
                          ## 2: methods::new(def, ...)
                          ## 1: GDialog$new(NULL, msg = "asdf")

                          widget$hide()
                          
                          if(length(msg) > 1)
                            widget["secondary-text"] <<- paste(msg[-1], collapse = "\n")

                          modify_widget()

                          
                          widget$SetTitle(title)
                          widget$GrabFocus()
                          widget$GetWindow()$Raise()
                          widget$setDefaultResponse(GtkResponseType["ok"])

                          initFields(block=widget)
                          callSuper(toolkit)
                        },
                        get_buttons=function() {
                          "Return string indicating buttons, cf GtkButtonsType"
                          "GTK_BUTTONS_CLOSE"
                        },
                        ok_response=function() {
                          "Response for ok button"
                          NULL
                        },
                        cancel_response=function() {
                          "Response for cancel button"
                          NULL
                        },
                        modify_widget=function() {
                          "Modify widget, eg. add input area"
                        },
                        run=function() {
                          "Run dialog in modal mode"
                            ## run in modal mode
                          widget$showAll()
                          response = widget$Run()
                          
                          if (response == GtkResponseType["close"] ||
                              response == GtkResponseType["delete-event"] ||
                              response == GtkResponseType["cancel"]) {
                            ret <- cancel_response()
                            widget$Destroy()
                          } else if(response == GtkResponseType["ok"]) {
                            ret <- ok_response()
                            widget$Destroy()
                          } else {
                            ret <- cancel_response()
                            widget$Destroy()
                          }
                          invisible(ret)
                        }
                        ))



##' toolkit implementation for gmessage
##'
##' @inheritParams gWidgets2::ginput
##' @return NULL
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gmessage guiWidgetsToolkitRGtk2
##' @S3method .gmessage guiWidgetsToolkitRGtk2
.gmessage.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                             msg,
                                             title = "message",
                                             icon = c("info","warning","error","question"),
                                             parent=NULL,
                                             ...
                                             ) {

  dlg <- GMessage$new(toolkit, msg, title, icon, parent, ...)
  dlg$run()
}

##' subclass for message dialog
##'
##' @param ... passed to constructor
GMessage <- setRefClass("GMessage", contains="GDialog")



##' toolkit implementation for gconfirm
##'
##' @inheritParams gWidgets2::ginput
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gconfirm guiWidgetsToolkitRGtk2
##' @S3method .gconfirm guiWidgetsToolkitRGtk2
.gconfirm.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                              msg,
                                              title = "Confirm",
                                              icon = c("info","warning","error","question"),
                                              parent=NULL,
                                              ...
                                              ) {
  dlg <- GConfirm$new(toolkit, msg, title, icon, parent, ...)
  dlg$run()

}

## class for confirmation dialog
GConfirm <- setRefClass("GConfirm",
                        contains="GDialog",
                        methods=list(
                          ok_response=function() TRUE,
                          cancel_response=function() FALSE,
                          get_buttons=function() "GTK_BUTTONS_OK_CANCEL"
                          ))
                        


##' toolkit implmentation of ginput
##'
##' @inheritParams gWidgets2::ginput
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .ginput guiWidgetsToolkitRGtk2
##' @S3method .ginput guiWidgetsToolkitRGtk2
.ginput.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                           msg,
                                           text="",
                                           title = "Input",
                                           icon = c("info","warning","error","question"),
                                           parent=NULL,                   
                                           ...
                                           ) {
  dlg <- GInput$new(toolkit, msg, title, icon, parent, ...)
  dlg$set_text(text)
  dlg$run()
}         


GInput <- setRefClass("GInput",
                      contains="GDialog",
                      fields=list(
                        entry="ANY"
                        ),
                      methods=list(
                        get_buttons=function() "GTK_BUTTONS_OK_CANCEL",
                        ok_response=function() entry$getText(),
                        cancel_response=function() character(0),
                        modify_widget=function() {
                          ## define entry
                          entry <<- gtkEntry()
                          widget$GetVbox()$PackStart(entry) 
                          gSignalConnect(entry, "activate", function(...) {
                            widget$response(GtkResponseType["ok"])
                          })
                        },
                        set_text=function(txt) {
                          entry$setText(txt)
                          entry$selectRegion(0L, -1L)
                          entry$grabFocus()
                        }
                        ))

##' toolkit implementation
##'
##' @inheritParams gWidgets2::gbasicdialog
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gbasicdialog guiWidgetsToolkitRGtk2
##' @S3method .gbasicdialog guiWidgetsToolkitRGtk2
.gbasicdialog.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                                 title = "Dialog",
                                                 parent=NULL,
                                                 do.buttons=TRUE,
                                                 handler = NULL,
                                                 action = NULL,
                                                 ...
                                                 ) {
            
  obj <- GBasicDialog$new(toolkit,
                          title=title, parent=parent, do.buttons=do.buttons,
                          handler=handler, action=action, 
                          ...)
  obj
}


## class for basic dialog
GBasicDialog <- setRefClass("GBasicDialog",
                    contains="GContainer",
                    fields=list(
                      handler="ANY",
                      action="ANY"
                      ),
                    methods=list(
                      initialize=function(toolkit=NULL,
                        title = "Dialog",
                        parent=NULL,
                        do.buttons=TRUE,
                        handler = NULL,
                        action = NULL,
                        ...) {
                        
                        widget <<- gtkHBox() 
                        
                        ## parent
                        .parent <- parent
                        if(!is.null(.parent)) {
                          .parent <- getBlock(.parent)
                          if(!is(.parent,"GtkWindow"))
                            .parent <- .parent$GetWindow()
                          if(!is(.parent,"GtkWindow"))
                            .parent <- NULL          # give up
                        } else {
                          .parent <- gtkWindowNew(show=FALSE)
                        }
            

                        buttons <- c("ok", "cancel")

                        ## can override, though not included here
                        buttonMap <- function(name) {
                          if(name == "ok")
                            list("gtk-ok", GtkResponseType["ok"])
                          else if(name =="yes")
                            list("gtk-yes", GtkResponseType["ok"])
                          else if(name == "cancel")
                            list("gtk-cancel", GtkResponseType["cancel"])
                          else if(name == "close")
                            list("gtk-close", GtkResponseType["close"])
                          else if(name =="no")
                            list("gtk-no", GtkResponseType["cancel"])
                          else
                            list("gtk-yes", GtkResponseType["ok"])
                        }
                        
                        l <- list(title=title, parent=.parent, flags=c("modal"), show=FALSE)
                        for(i in buttons) {
                          m <- buttonMap(i)
                          l[[length(l) + 1]] <- m[[1]]
                          l[[length(l) + 1]] <- m[[2]]
                        }
                        
                        ## do buttons?
                        if(do.buttons) {
                          dlg <- do.call("gtkDialog", l)
                        } else {
                          dlg <- gtkDialogNew(show=FALSE)
                          ## hide separator and button box. Uses internals -- bad idea if widget changes
                          sapply(dlg$getChildren()[[1]]$getChildren(), gtkWidgetHide)
                        }
                        dlg$setTransientFor(.parent)
                        
                        dlg$SetTitle(title)
                        dlg$setDefaultResponse(GtkResponseType["ok"])
                        dlg$getVbox()$PackStart(widget)
                        dlg$grabFocus()
                        
                                
                        initFields(block=dlg,
                                   handler=handler,
                                   action=action
                                   )

                        callSuper(toolkit)
                      },
                      add_child=function(child, ...) {
                        widget$packStart(getBlock(child), expand=TRUE, fill=TRUE)
                        child_bookkeeping(child)
                      },
                      dispose=function() {
                        block$destroy()
                      },
                      set_visible=function(...) {
                        block$show()
                        response <- block$run()

                        h <- list(obj=.self, action=action)
                        if(response == GtkResponseType["cancel"] ||
                           response == GtkResponseType["close"] ||
                           response == GtkResponseType["delete-event"]) {
                          ## cancel action
                          ret <- FALSE
                        } else if(response == GtkResponseType["ok"]) {
                          if(!is.null(handler))
                            handler(h)
                          ret <- TRUE              # was widget, but TRUE now
                        } else if(response == GtkResponseType["delete-event"]) {
                          ## window manager close
                          ret <- FALSE
                        } else if(response == GtkResponseType["none"]) {
                          ## dispose() call
                          ret <- FALSE
                        } else {
                          ret <- FALSE
                        }
                        
                        block$Destroy()
                        return(invisible(ret))
                      }
                      ))


##' toolkit implementation of galert
##'
##' @param delay delay
##' @inheritParams gWidgets2::gaction
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .galert guiWidgetsToolkitRGtk2
##' @S3method .galert guiWidgetsToolkitRGtk2
.galert.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                            msg,
                                            title = "message",
                                            delay = 3,
                                            parent=NULL,
                                            ...
                                            ) {

            ## insert an info bar here?
            if(is(parent, "GWindow")) {
              parent$set_infobar(msg)
            } else {
              ## make a transient dialog window
              w <- gtkWindow(show=FALSE)
              w$setTitle(title)
              w$setDefaultSize(300, 150)
              evb <- gtkEventBox()
              evb$SetVisibleWindow(FALSE)
              evb$AddEvents(GdkEventMask["all-events-mask"])
              l <- gtkLabel(msg)
              evb$add(l); w$add(evb)

              if(!is.null(parent)) {
                parent <- getBlock(parent)
                if(!is(parent,"GtkWindow"))
                  parent <- parent$GetWindow()
                if(!is(parent,"GtkWindow"))
                  parent <- NULL          # give up
              }
              if(!is.null(parent))
                w$setTransientFor(parent)

              f <- function(...) {
                timer$stop_timer()
                if(!is(w, "<invalid>"))
                  w$destroy()
                FALSE
              }
              gSignalConnect(evb, "motion-notify-event", f=f)

              w$show()

              timer <- gtimer(delay*1000, FUN=f, one.shot=TRUE, toolkit=toolkit)
            }
          }
 
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gcalendar.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gcalendar
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gcalendar guiWidgetsToolkitRGtk2
##' @S3method .gcalendar guiWidgetsToolkitRGtk2
.gcalendar.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                               text="",
                                               format="%Y-%m-%d",
                                               handler = NULL,action = NULL, container = NULL, ... ) {
  GCalendar$new(toolkit,
                 text=text,
                format=format,
                handler = handler,action = action, container = container, ...)
}
  


## Calendar
GCalendar <- setRefClass("GCalendar",
                         contains="GWidget",
                         fields=list(
                           "format"="character"
                           ),
                         methods=list(
                           initialize=function(toolkit=NULL,
                             text="",
                             format="%Y-%m-%d",
                             handler, action, container, ...) {

                             block <<- gtkHBox()
                             widget <<- gtkEntry()
                             widget$setText(text)
                             button <- gtkButton("Date...")
                             
                             initFields(format=format,
                                        change_signal="activate")

                             block$packStart(widget, expand=TRUE, fill=TRUE)
                             block$packStart(button)

                             calendar_callback <- function(h,...) {
                               ## called when button is clicked
                               ## pop up a calendar, when date selected, copy to entry
                               win <- gtkWindowNew(show=FALSE)
                               cal <- gtkCalendarNew()
                               if(nchar(cur_date <- widget$getText())) {
                                 tmp <- as.numeric(strsplit(cur_date, "-")[[1]])
                                 cal$selectDay(tmp[3])
                                 cal$selectMonth(tmp[2] - 1L, tmp[1])
                               }
                               win$Add(cal)
                               cal$Show();
                               win$Show()

                               cal$AddCallback("day-selected-double-click", function(w,...) {
                                 l <- cal$GetDate()
                                 date_selected <- paste(l$year, l$month+1, l$day,sep="-",collapse="-")
                                 date_selected <- format(as.Date(date_selected,format=format))
                                 set_value(date_selected)
                                 win$Destroy()
                               })
                             }
                             gSignalConnect(button, "clicked", f=calendar_callback)

                             
                             add_to_parent(container, .self, ...)
                             
                             handler_id <<- add_handler_changed(handler, action)
                             
                             callSuper(toolkit)
                           },
                           get_value=function(drop=TRUE, ...) {
                             val <- widget$getText()
                             cur_date <- try(as.Date(val, format=format))
                             if(is.na(cur_date)) 
                               cur_date <- as.Date(NA)
                             if(missing(drop) || is.null(drop) || drop)
                               format(cur_date, format=format)
                             else
                               cur_date
                           },
                           set_value=function(value, ...) {
                             widget$setText(value)
                             invoke_change_handler()
                           }
                           ## ,
                           ## add_handler_changed=function(handler, action=NULL, ...) {
                           ##   if(missing(handler) || is.null(handler))
                           ##     return()
                           ##   f <- function(h, widget, event, ...) {
                           ##     keyval <- event$GetKeyval()
                           ##     if(keyval == GDK_Return) {
                           ##       handler(h, widget, event, ...)
                           ##       return(TRUE)
                           ##     } else {
                           ##       return(FALSE)
                           ##     }
                           ##   }
                           ##   add_handler(change_signal, f, action=action, ...) 
                           ## }
                           ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gfile.R"
##' @include GWidget.R
NULL

##' Toolkit implementation
##'
##' @inheritParams gWidgets2::gfile
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gfile guiWidgetsToolkitRGtk2
##' @S3method .gfile guiWidgetsToolkitRGtk2
.gfile.guiWidgetsToolkitRGtk2 <- function(toolkit,
                                          text = "",
                                          type = c("open","save","selectdir"),
                                          initial.filename = NULL,
                                          initial.dir = getwd(),
                                          filter = list(),
                                          multi=FALSE,
                                          ...) {
  ## make dialog, return character class object (character(0) if no selectino)
  type <- match.arg(type)
  avail_types <- c(
                   "open"="open",
                   "save"="save",
                   "selectdir"="select-folder",
                   "createdir"="create-folder"
                   )
            
  actiontype <- GtkFileChooserAction[avail_types[type]]
  button_with_id = list(
    "ok"= c("gtk-ok",GtkResponseType["ok"]),
    "cancel" = c("gtk-cancel",GtkResponseType["cancel"])
    )
            
  which_buttons <- switch(type,
                          "save"=c("ok","cancel"),
                          "open"=c("ok","cancel"),
                          "selectdir"=c("ok","cancel")
                          )

  filechooser <- gtkFileChooserDialogNew(title=text, action=actiontype)
  filechooser$setSelectMultiple(multi)
            
  for(i in which_buttons) 
    filechooser$AddButton(button_with_id[[i]][1],button_with_id[[i]][2])
            
  ## Add filter
  if(length(filter) && type %in% c("open","save")) {
    if(is.character(filter)) {
      ## make alist
      filter <- sapply(names(filter), function(nm) {
        list(patterns=paste("*.", filter[nm], sep=""))
      }, simplify=FALSE)
    }
    
  
    
    for(i in names(filter)) {
      filefilter <- gtkFileFilterNew()
      filefilter$SetName(i)
      if(!is.null(filter[[i]]$patterns)) {
        for(pattern in filter[[i]]$patterns)
          filefilter$AddPattern(pattern)
      }
      if(!is.null(filter[[i]]$mime.types)) {
        for(mime.type in filter[[i]]$mime.types)
          filefilter$AddMimeType(mime.type)
      }
      filechooser$AddFilter(filefilter)
    }
  }

  ## boy this could be tidied up, but is it correct?
  if(type == "open") {
    if(!is.null(initial.filename))
      filechooser$SetFilename(initial.filename)
    filechooser$setCurrentFolder(initial.dir)
  } else if(type == "open") {
    if(!is.null(initial.filename))
      filechooser$SetFilename(initial.filename)
    filechooser$setCurrentFolder(initial.dir)
  } else if(type == "save") {
    if(!is.null(initial.filename))
      filechooser$SetFilename(initial.filename)
    filechooser$setCurrentFolder(initial.dir)
  }
  
  ## this makes it modal
  response <- filechooser$Run()
  file <- unlist(filechooser$GetFilenames())

  if(response == GtkResponseType["cancel"]) {
    ## just close
    filechooser$Destroy()
    return(character(0))
  } else if(response == GtkResponseType["ok"]) {
    filechooser$Destroy()
    return(file)
  } else {
    filechooser$Destroy()
    return(character(0))
  }
}
                                          

##' Toolkit constructor
##'
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gfilebrowse guiWidgetsToolkitRGtk2
##' @S3method .gfilebrowse guiWidgetsToolkitRGtk2
.gfilebrowse.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                 text = "",
                                                 type = c("open","save","selectdir"),
                                                 initial.filename = NULL,
                                                 initial.dir = getwd(),
                                                 filter = list(),
                                                 quote=TRUE,
                                                 handler=NULL,
                                                 action=NULL,
                                                 container = NULL,
                                                 ... ) {
  GFileBrowse$new(toolkit,
            text=text, type=type, initial.filename=initial.filename, initial.dir = initial.dir,
            filter=filter, quote=quote, handler=handler, action=action, container=container, ...)
}


## XXX
GFileBrowse <- setRefClass("GFileBrowse",
                           contains="GWidgetWithItems",
                           fields=list(
                             button="ANY",
                             initial.text="character"
                             ),
                           methods=list(
                              initialize=function(
                                toolkit=NULL,
                                text = "",
                                type = c("open", "save", "selectdir"),
                                initial.filename = NULL,
                                initial.dir = getwd(),
                                filter = list(),
                                quote=TRUE,
                                handler=NULL,
                                action=NULL,
                                container = NULL,
                                ... ) {
                                
                                block <<- gtkHBox()
                                widget <<- gtkEntry()
                                initial.text <<- text
                                widget$setText(text)
                                button <<- gtkButtonNewFromStock("gtk-open") # gtk-file isn't working

                                block$packStart(widget, expand=TRUE, fill=TRUE)
                                block$packStart(button)
                                gSignalConnect(button, "clicked", f=function(...) {
                                 ret <- gfile(text=text, type=type,
                                              initial.filename=initial.filename, initial.dir = initial.dir,
                                              filter=filter, toolkit=toolkit)
                                 if(length(ret))
                                   set_value(ret)
                                })

                                initFields(change_signal="activate")

                                add_to_parent(container, .self, ...)

                                handler_id <<- add_handler_changed(handler, action)

                                callSuper(toolkit)
                              },
                              get_value=function( ...) {
                                x <- widget$getText()
                                if (x == initial.text)
                                  return(character(0))
                                Encoding(x) <- "UTF-8"
                                x
                              },
                              set_value=function(value, ...) {
                                ## should we check file.exists?
                                widget$setText(value)
                                invisible(notify_observers(signal=change_signal))
                              },
                              add_handler_changed=function(handler, action=NULL, ...) {
                                add_handler(change_signal, handler, action=action, ...)
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gaction.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gaction
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gaction guiWidgetsToolkitRGtk2
##' @S3method .gaction guiWidgetsToolkitRGtk2
.gaction.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                             label, tooltip=NULL, icon = NULL, key.accel = NULL,
                                             handler = NULL,action = NULL, parent = NULL, ... ) {
  GAction$new(toolkit,
              label, tooltip=tooltip, icon = icon, key.accel = key.accel,
              handler = handler,action = action, parent = parent, ...)
}


## GAction class
GAction <- setRefClass("GAction",
                       contains="GWidget",
                       fields=list(
                         accel_key="ANY"
                         ),
                       methods=list(
                         initialize=function(toolkit=NULL,
                           label="", tooltip=NULL, icon = NULL, key.accel = NULL,
                           handler, action=NULL, parent, ...) {

                           
                           
                           widget <<- gtkAction(name=make.names(label),
                                                label=label,
                                                tooltip=tooltip,
                                                stock.id=getStockIconByName(icon, toolkit=toolkit))
                           
                           initFields(block=widget,
                                      accel_key=key.accel)

                           if(!is.null(parent) && !is.null(handler))
                             add_key_accel(parent, handler)

                           handler_id <<- add_handler_changed(handler, action)
                           
                           callSuper(toolkit)
                         },
                         add_key_accel=function(parent, handler) {
                           "Hack to add in accelerator button binding"
                           ## accel buttons
                           if(!is.null(accel_key) && !is.null(parent)) {
                             toplevel <- getBlock(parent)$toplevel
                             ## mask Shift-1, Control-4 alt-8
                             ## key sprintf("GDK_%s",key)
                             ## flag GtkAccelFlags -- 1
                             if(grepl("^Control", accel_key) ||
                                grepl("^Alt", accel_key) ||
                                grepl("^Shift", accel_key)) {
                               tmp <- strsplit(accel_key, "-")[[1]]
                               modifier <- c(Shift="shift-mask", "Control"="control-mask", Alt="mod1-mask")[tmp[1]]
                               key <- sprintf("GDK_%s", tmp[2])
                             } else {
                               modifier <- "modifier-mask"
                               key <- sprintf("GDK_%s", accel_key)
                             }
                             a <- gtkAccelGroup()
                             toplevel$addAccelGroup(a)
                             a$connect(get(key), modifier, "visible", function(...) {
                               h <- list(action=action)
                               handler(h, ...)
                               TRUE
                             })
                           }
                         },
                         get_value=function( ...) {
                           widget$getLabel()
                         },
                         set_value=function(value, ...) {
                           widget$setLabel(value)
                         },
                         get_tooltip=function(...) {
                           widget['tooltip']
                         },
                         set_tooltip=function(value, ...) {
                           widget$setTooltip(paste(value, "\n"))
                         },
                         add_handler_changed=function(handler, action=NULL, ...) {
                           add_handler("activate", handler, action=action, ...)
                         }
                         ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/ggraphics.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @param width width of device (pixels)
##' @param height height of device (pixels)
##' @param dpi dots per inch
##' @param ps pointsize
##' @inheritParams gWidgets2::gwidget
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .ggraphics guiWidgetsToolkitRGtk2
##' @S3method .ggraphics guiWidgetsToolkitRGtk2
.ggraphics.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                               width = dpi*6, height = dpi*6, dpi = 75, ps = 12,    
                                               handler = NULL,action = NULL, container = NULL, ... ) {
  GGraphics$new(toolkit,
                width=width, height=height, dpi=dpi, ps=ps,
                handler = handler,action = action, container = container, ...)
}


## 
GGraphics <- setRefClass("GGraphics",
                         contains="GWidget",
                         fields=list(
                           device_number="numeric",
                           rubber_band="environment"
                           ),
                         methods=list(
                           initialize=function(toolkit=NULL,
                             width = dpi * 6, height = dpi * 6, dpi = 75, ps = 12, 
                             handler=NULL, action=NULL, container=NULL, ...) {
                             
                             
                             widget <<- gtkDrawingAreaNew()
                             asCairoDevice(widget, pointsize=ps)
                             widget$AddEvents(GdkEventMask["all-events-mask"])
                             
                             initFields(block=widget)
                             
#                             if(!is.null(width) & !is.null(height))
#                               set_size(c(width=width, height=height))

                             add_widget_events()
                             add_rubber_band()
                             if(!getWithDefault(list(...)[["no_popup"]], FALSE))
                               add_right_mouse_menu()
                             add_to_parent(container, .self, ...)
                             
                             handler_id <<- add_handler_changed(handler, action)
                             
                             callSuper(toolkit)
                           },
                           add_widget_events = function() {
                             "Add events to widget to customize behaviours"
                             gSignalConnect(widget, signal="map-event", f = function(w, e, ...) {
                               if(is.null(widget$GetData(".devnum"))) {
                                 asCairoDevice(widget, pointsize=ps) # turn into cairo device
                                 device_number <<- widget$GetData(".devnum")
                               }
                               return(TRUE)             # don't propogate
                             })
                             gSignalConnect(widget, "button-press-event", f=function(w,...) {
                               dev.set(w$getData(".devnum"))
                               return(FALSE)
                             })
                             gSignalConnect(widget, "destroy-event", f=function(w, ...) {
                               dev.off(w$getData(".devnum"))
                               return(FALSE)
                             })
                             
                             gSignalConnect(widget, "realize", f=function(...) {
                               gdkWindowProcessAllUpdates()
                               while (gtkEventsPending()) gtkMainIterationDo(blocking=FALSE)
                             })
                           },
                           draw_rectangle=function(x0, x, y0, y) {
                             "Draw rectangle"
                             x <- c(x0, x); y <- c(y0, y)
                             x0 <- min(x); x <- max(x)
                             y0 <- min(y); y <- max(y)

                             a.width <- widget$getAllocation()$allocation$width
                             a.height <- widget$getAllocation()$allocation$height

                             ## background style
                             gcb <- gdkGCNew(widget$window)
                             gcb$copy(widget["style"]$blackGc)
                             gcb$setRgbFgColor(gdkColorParse("gray50")$color)
                             gcb$setLineAttributes(line.width=1, line.style=GdkLineStyle["solid"],
                                                   cap.style=GdkCapStyle["butt"], join.style=GdkJoinStyle["miter"])
                             ## foreground style
                             gc <- gdkGCNew(widget$window)
                             gc$copy(widget["style"]$blackGc)
                             gc$setRgbFgColor(gdkColorParse("black")$color)
                             gc$setRgbBgColor(gdkColorParse("gray50")$color)
                             gc$setLineAttributes(line.width=1, line.style=GdkLineStyle["double-dash"],
                                                  cap.style=GdkCapStyle["butt"], join.style=GdkJoinStyle["miter"])
                             gc$setDashes(c(8, 4))

                             ## the entire rectangle to clear
                             rect <- as.GdkRectangle(c(x=0, y=0, width=a.width, height=a.height))
                             widget$setData("lastRect", rect)

                             for (i in 1:2) {
                               ## draw in background color first
                               tmp.gc <- if (i == 1) gcb else gc
                               gdkDrawRectangle(widget$window, gc=tmp.gc, filled=FALSE, x=x0, y=y0, width=x-x0, height=y-y0)
                             }
                             
                             gdkWindowProcessAllUpdates()
                             while (gtkEventsPending()) gtkMainIterationDo(blocking=FALSE)
                           },
                           clear_rectangle=function(){
                             "clear rectangle"
                             last <- widget$getData("lastRect")
                             if(!is.null(last)) 
                               widget$window$invalidateRect(last, FALSE)
                             gdkWindowProcessAllUpdates()
                             while (gtkEventsPending()) gtkMainIterationDo(blocking=FALSE)
                           },
                           add_rubber_band=function() {
                             "add rubber bandings. This is from  the excellent playwith package by Felix Andrews"
                             e <- rubber_band <<- environment()
                             
                             ## add environment and values to da
                             e$dragging <- FALSE
                             e$x0 <- e$y0 <- e$x <- e$y <- 0
                             widget$setData("env", e)

                             ## need to bind drag actions: click, motion, release
                             gSignalConnect(widget, "button-press-event", f=function(w, e) {
                               if(isRightMouseClick(e))
                                 return(FALSE)
                               clear_rectangle()
                               
                               a.width <- w$getAllocation()$allocation$width
                               a.height <- w$getAllocation()$allocation$height


                               env <- rubber_band
                               env$x0 <- env$x <- e$x
                               env$y0 <- env$y <- e$y
                               env$dragging <- TRUE
                               return(FALSE)
                             })
                             
                             gSignalConnect(widget, "motion-notify-event", f=function(w, e) {
                               env <- rubber_band
                               ## are we dragging?
                               if(env$dragging) {
                                 clear_rectangle()
                                 env$x <- e$x
                                 env$y <- e$y
                                 ## did we move enough? 10 pixels say
                                 
                                 if(max(abs(env$x - env$x0), abs(env$y - env$y0)) > 10)
                                   draw_rectangle(env$x0, env$x, env$y0, env$y)
                
                               }
                               return(FALSE)
                             })
            
                             gSignalConnect(widget, "button-release-event", f=function(w, e) {
                               if(isRightMouseClick(e))
                                 return(FALSE)
                               env <- rubber_band
                               ## remove draggin
                               env$dragging <- FALSE
                               clear_rectangle()
                               return(FALSE)
                             })
                           },
                           copyToClipboard = function() {
                             da <- widget
                             if(!is(da, "GtkDrawingArea"))
                               da <- getWidget(da)                 # ggraphics object
                             da.w <- da$getAllocation()$width
                             da.h <- da$getAllocation()$height
                             buf <- gdkPixbufGetFromDrawable(src=da$window, src.x=0, src.y=0,
                                                             dest.x=0, dest.y=0, width=da.w, height=da.h)
                             gtkClipboardGet("CLIPBOARD")$setImage(buf)
                           },
                           add_right_mouse_menu = function() {
                             "Add menu to right mouse trigger"
                             l <- list()
                             l$copyAction <- gaction("Copy", "Copy current graph to clipboard", icon="copy",
                                                     handler=function(h, ...) copyToClipboard(obj))
                             l$printAction <- gaction("Save", "Save current graph", icon="save",
                                                      handler=function(h,...) {
                                                        fname <- gfile(gettext("Filename to save to (pdf)"), type="save")
                                                        if(nchar(fname)) {
                                                          if(!file.exists(fname) || gconfirm(gettext("Overwrite file?")))
                                                            dev.copy2pdf(file=fname)
                                                        }
                                                      })
                             add_3rd_mouse_popup_menu(l)
                           },
                           get_value=function( ...) {
                             
                           },
                           set_visible=function(value, ...) {
                             "Set as current device, raise"
                             if(value) {
                               devnum <- widget$GetData(".devnum")
                               if(!is.null(devnum))
                                 dev.set(devnum)
                               set_focus(TRUE)
                             }
                           },
                           set_value=function(value, ...) {
                             "Save figure to file specfied by value"
                             XXX("Complete, code is a hack")
                           },
                           ##
                           drawable_to_ndc = function() {
                             ## convert to normalized device coordinates
                             e <- rubber_band
                             x.pixel <- sort(c(e$x0, e$x))
                             y.pixel <- sort(c(e$y0, e$y))
  
                             da.w <- widget$getAllocation()$allocation$width
                             da.h <- widget$getAllocation()$allocation$height 
                             
                             ndc <- list(x=x.pixel/da.w, y= 1- rev(y.pixel/da.h))
                             return(ndc)
                           },
          
                           add_handler_changed=function(handler, action=NULL, ...) {
                             "Change handler is called after rubber band selection is updated"
                             if(!is_handler(handler)) return()
                             decorator <- function(FUN) {
                               force(FUN)
                               f <- function(self, w, e, ...) {
                                 if(!isFirstMouseClick(e))
                                   return(FALSE)
                                 coords <- drawable_to_ndc()
                                 FUN(self,
                                     x=grconvertX(coords$x, from="ndc", to="user"),
                                     y=grconvertY(coords$y, from="ndc", to="user")
                                     )
                                 return(FALSE)             # propagate
                               }
                               f
                             }
                             add_handler("button-release-event", handler, action=action, decorator=decorator)
                           },
                           add_handler_selection_changed=function(handler, action=NULL, ...) {
                             add_handler_changed(handler, action, ...)
                           },
                           add_handler_clicked=function(handler, action=NULL, ...) {
                             if(!is_handler(handler)) return()
                             decorator <- function(FUN) {
                               force(FUN)
                               f = function(self, w, e,...) {
                                 if(!isFirstMouseClick(e))
                                   return(FALSE)
                                 
                                 ## changes to allocation storage with newer RGtk2
                                 xclick <- e$GetX()
                                 yclick <- e$GetY()
                                 da.w <- w$getAllocation()$allocation$width
                                 da.h <- w$getAllocation()$allocation$height 
                                 
                                 
                                 x <- xclick/da.w
                                 y <- (da.h - yclick)/da.h
                                 
                                 ## put into usr coordinates
                                 FUN(self,
                                     x=grconvertX(x, from="ndc", to="user"),
                                     y=grconvertY(y, from="ndc", to="user"),
                                     width=da.w,
                                     height=da.h,
                                     xclick=xclick,
                                     yclick=yclick)
                                 return(FALSE)
                               }
                               f
                              }
                              add_handler("button-press-event", handler, action=action, decorator=decorator, ...)
                            },
                           add_handler_mouse_motion=function(handler, action=NULL, ...) {
                             decorator <- function(FUN) {
                               if(!is_handler(handler)) return()
                               ## need motion decorator
                               force(FUN)
                               f <- function(self, w, e, ...) {
                                 
                                 xclick <- e$GetX()
                                 yclick <- e$GetY()
                                 da.w <- w$getAllocation()$allocation$width
                                 da.h <- w$getAllocation()$allocation$height 
                                 
                                 
                                 x <- xclick/da.w
                                 y <- (da.h - yclick)/da.h

                                 ## put into usr coordinates
                                 FUN(self,
                                     x=grconvertX(x, from="ndc", to="user"),
                                     y=grconvertY(y, from="ndc", to="user"),
                                     width=da.w,
                                     height=da.h,
                                     xclick=xclick,
                                     yclick=yclick)
                                 FALSE
                               }
                               f
                             }
                             add_handler("motion-notify-event", handler, action=NULL, decorator=decorator)
                           }
                           ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtable.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gtable
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gtable guiWidgetsToolkitRGtk2
##' @S3method .gtable guiWidgetsToolkitRGtk2
.gtable.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                         items,
                                         multiple = FALSE,
                                         chosen.col = 1,
                                         icon.col = NULL,
                                         tooltip.col=NULL,
                                         handler = NULL, action = NULL,
                                         container = NULL, ... ) {
  GTable$new(toolkit,
           items=items,
           multiple=multiple,
           chosen.col=chosen.col,
           icon.col = icon.col,
           tooltip.col = tooltip.col,
           handler=handler,
             action=action,
           container=container ,...)
}


## helper to make treeview columns based on type of data
## Need S3 methods defined outside of reference class method, not sure why
make_treeview_column <- function(x, col_no, self) UseMethod("make_treeview_column")
make_treeview_column.default <- function(x, col_no, self) {
  ## Return a tree view column instance to render x, located in 0-based col in model
  cellrenderer <- gtkCellRendererText()
  view_col <- gtkTreeViewColumnNew()
  view_col$setResizable(TRUE)
  view_col$PackStart(cellrenderer, TRUE)
  view_col$AddAttribute(cellrenderer, "text", col_no)

  ## we override built in label
  event_box <- gtkEventBox()
  event_box$SetVisibleWindow(FALSE)
  label <- gtkLabel()
##  event_box$addEvents('all-events-mask')
  event_box$add(label)
  event_box$setAboveChild(TRUE)         # gets events to box
  
  view_col$setWidget(event_box)
  view_col
}

## need to format value for Dates
make_treeview_column.Date <- function(x, col_no, self) {
  ## Return a tree view column instance to render x, located in 0-based col in model
  cellrenderer <- gtkCellRendererText()
  view_col <- gtkTreeViewColumnNew()
  view_col$setResizable(TRUE)
  view_col$PackStart(cellrenderer, TRUE)
  view_col$AddAttribute(cellrenderer, "text", col_no)

  view_col$setCellDataFunc(cellrenderer, function(vc, cr, model, iter, ...) {
    ## set cell value by formatting
    col <- self$find_col_no(vc)
    row <- as.numeric(model$getPath(iter)$toString()) + 1L
    model <- self$get_model()
    val <- model[row, col]
    cr["text"] <- format(val)
  })
  ## we override built in label
  event_box <- gtkEventBox()
  event_box$SetVisibleWindow(FALSE)
  label <- gtkLabel()
##  event_box$addEvents('all-events-mask')
  event_box$add(label)
  event_box$setAboveChild(TRUE)         # gets events to box
  
  view_col$setWidget(event_box)
  view_col
}
make_treeview_column.POSIXt <- make_treeview_column.Date

##' Class for gtable widget
##'
##' This GTable class for RGtk2 implements a few additional reference
##' methods: \code{hide_names} to hide the header names;
##' \code{remove_popup_menu} to remove the popup menu;
##' \code{add_popup} to add a popup menu
##' @rdname gWidgets2RGtk2-package
GTable <- setRefClass("GTable",
                      contains="GWidget",
                      fields=list(
                        items="ANY",
                        chosen_col="integer",
                        icon_col="IntegerOrNULL",
                        tooltip_col="IntegerOrNULL"
                        ),
                      methods=list(
                              initialize=function(toolkit=NULL,
                                items=NULL,
                                multiple = FALSE,
                                chosen.col = 1,
                                icon.col = NULL,
                                tooltip.col=NULL,
                                handler = NULL, action = NULL,
                                container = NULL, ... ) {

                                
                                widget <<- gtkTreeViewNew()
                                
                                block <<- gtkScrolledWindowNew()
                                block$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                                block$add(widget)
                                
                                if(multiple)
                                  set_selection_mode("multiple")
                              
                                
                                if(missing(items) || length(items) > 1)
                                  widget$SetRulesHint(TRUE)
                                widget$SetEnableSearch(TRUE)
                                widget$setSearchColumn(1 + is.null(icon.col) - 1L)

                                ## we want column index, not name
                                if(is.character(icon.col))
                                  icon.col <- match(icon.col, names(items))
                                if(is.numeric(icon.col))
                                  icon.col <- as.integer(icon.col)
                                
                                if(is.character(tooltip.col))
                                  tooltip.col <- as.integer(match(tooltip.col, names(items)))
                                if(is.numeric(tooltip.col))
                                  tooltip.col <- as.integer(tooltip.col)

                                initFields(chosen_col=as.integer(chosen.col),
                                           icon_col = icon.col,
                                           tooltip_col=tooltip.col,
                                           change_signal="changed",
                                           default_expand=TRUE,
                                           default_fill=TRUE,
                                           toolkit=toolkit # needed here for gmenu call later
                                           )


                                set_items(items)
                                
                                add_to_parent(container, .self, ...)

                                ## hack in click events here
                                click_decorator <- function(FUN) {
                                  force(FUN)
                                  f <- function(self, w, e, ...) {
                                    if(e$getButton() == 1) {
                                      if(as.numeric(e$getType()) == GdkEventType['button-press']) {
                                        self$notify_observers(signal="button-press-event")
                                      }
                                      if(as.numeric(e$getType()) == GdkEventType['2button-press']) {
                                        self$notify_observers(signal="2button-press-event")
                                      }
                                    }
                                    FALSE
                                  }
                                  f
                                }
                                connect_to_toolkit_signal("button-press-event", click_decorator)

                                
                                handler_id <<- add_handler_changed(handler, action)

                                callSuper(toolkit)
                              },
                        clear_columns=function() {
                          "Clear out old treeview columns in preparation of new"
                          sapply(rev(widget$getColumns()), widget$removeColumn)
                        },
                        make_columns=function() {
                          "Make new columns, watching out for icons, tooltips, visible"
                          if(!is.null(icon_col)) {
                            widget$InsertColumn(make_icon_column(),0L)
                          }
                          if(!is.null(tooltip_col)) {
                            ## use column tooltip_col - 1L for a tooltip
                            x <- seq_along(items);
                            if(!is.null(tooltip_col)) {
                              widget$setTooltipColumn(tooltip_col - 1L)
                            }
                          }
                          ## now add columns, one by one
                          DF <- get_model()
                          sapply(get_valid_columns(), function(col) {
                            treeview_col <- make_treeview_column(DF[,col], col - 1L, .self)
                            widget$insertColumn(treeview_col, pos = -1) # at end
                          })
                          add_popup()
                        },
                        make_icon_column=function() {
                          "Make column for icons"
                          cellrenderer <- gtkCellRendererPixbufNew()
                          view.col <- gtkTreeViewColumnNew()
                          view.col$PackStart(cellrenderer, TRUE)
                          view.col$AddAttribute(cellrenderer, "stock-id", icon_col - 1L)
                          event_box <- gtkEventBox() # need this for consistency
                          label <- gtkLabel()
                          event_box$add(label)
                          view.col$setWidget(event_box)
                          view.col
                        },
                        default_popup_menu=function(col_index) {
                          "Provide default popup menu (passed to gmenu(..., popup=TRUE))"
                          actions <- list(sort_increasing=
                                          gaction("Sort (increasing)", handler=function(h, ...) {
                                            DF <- get_model()
                                            ind <- order(DF[,col_index], decreasing=FALSE)
                                            DF$setFrame(DF[][ind,])
                                          }),
                                          sort_decreasing=
                                          gaction("Sort (decreasing)", handler=function(h, ...) {
                                            DF <- get_model()
                                            ind <- order(DF[,col_index], decreasing=TRUE)
                                            DF$setFrame(DF[][ind,])
                                          }),
                                          gseparator(),
                                          gaction("Rename column", handler=function(h,...) {
                                            cur_nms <- get_names()
                                            out <- ginput("Rename column", text=cur_nms[col_index], parent=widget)
                                            if(nchar(out)) {
                                              cur_nms[col_index] <- out
                                              set_names(cur_nms)
                                            }
                                          })
                                          )
                          actions
                        },
                        add_popup_menu=function(menulist) {
                          f <- function(...) menulist
                          add_popup(f)
                        },
                        ## perhaps needs optimization, loops over all columns so n^2 stuff here.
                        find_col_no = function(view.col) {
                          ind <- which(sapply(widget$getColumns(), function(i) identical(i, view.col)))
                          ind - !is.null(icon_col)
                        },                        
                        add_popup=function(menu_fun=NULL) {
                          "Add a popup menu to the columns. Function should generate list of actions, ..."
                          if(is.null(menu_fun))
                            menu_fun <- .self$default_popup_menu
                          
                          
                          sapply(get_view_columns(), function(view.col) {
                            view.col$setClickable(TRUE)
                            col_no <- find_col_no(view.col)
                            popup <- gmenu(menu_fun(col_no), popup=TRUE, toolkit=toolkit)
                            event_box <- view.col$getWidget()
                            ## This is a *real* hack, as the following doesn't
                            ## work when I use event_box. NOt sure why
                            ## not, seems like the right combination of
                            ## arguments is given
                            btn <- event_box$getParent()$getParent()$getParent()
                            id <- gSignalConnect(btn, "button-press-event", f=function(w, e, ...) {
                              if(e$button == 1 && e$type == GdkEventType['button-press']) {
                                popup$widget$popup(button=e$button, activate.time=e$time)
                              }
                              FALSE
                            })
                          btn$setData("popup_id", id)
                          })
                        },
                        remove_popup_menu=function() {
                          "remove popup menu from column headers"
                          
                          sapply(get_view_columns(), function(view.col) {
                            view.col$setClickable(FALSE)
                            btn <- view.col$getWidget()$getParent()$getParent()$getParent()
                            if(!is.null(id <- btn$getData("popup_id")))
                              gSignalHandlerDisconnect(btn, id)
                          })
                        },
                        set_selection_mode=function(mode=c("none","single","browse", "multiple", "extended")) {
                          "Helper: Set the selection mode"
                          sel_model <- widget$getSelection()
                          sel_model$setMode(GtkSelectionMode[match.arg(mode)])
                        },
                        not_these=function() {
                          "Helper: Remove these indices due to icon_col, ..."
                          x <- unlist(list(icon_col, tooltip_col))
                          if(is.null(x))
                            x <- integer(0)
                          x
                        },
                        get_valid_columns=function() {
                          "Helper: get column indices less those for icons, tooltips, visible"
                          DF <- get_model()
                          if(!is(DF, "RGtkDataFrame"))
                            return(NULL)
                          j <- seq_len(dim(DF)[2] - 1L) # last col is ..visible
                          setdiff(j, not_these())
                        },
                        get_view_columns=function() {
                          "Helper: get non-icon columns to iterate over"
                          columns <- widget$getColumns()
                          if(!is.null(icon_col))
                            columns <- columns[-1]
                          columns
                        }, 
                        get_selected=function() {
                          "Get selected indices or numeric(0)"
                          sel_model <- widget$getSelection()
                          x <- sapply(sel_model$getSelectedRows()$retval, gtkTreePathToString)
                          if(is.null(x))
                            return(integer(0))
                          x <- as.numeric(x) + 1L # hide, deleted
                          
                          x
                        },
                        set_selected=function(ind) {
                          "Set selected rows by index"
                          old_ind <- get_selected()
                          sel_model = widget$getSelection()
                          block_handlers()
                          sel_model$unselectAll()
                       
                          lapply(ind, function(i) sel_model$selectPath(gtkTreePathNewFromString(i)))
                          unblock_handlers()
                          if ((length(ind) != length(old_ind)) ||
                              any(ind != old_ind))
                            invoke_change_handler()
                        },
                        get_model=function() {
                          "Helper: get rGtkDataFrame model, which is filtered"
                          m <- widget$getModel()
                          if(is(m, "GtkTreeModelFilter"))
                            m$getModel() # get past filter
                          else
                            NULL
                        },

                        ## implement basic methods
                        get_value=function(drop=TRUE, ...) {
                          "Get selected values by value (or character(0))"

                          idx <- get_selected()
                          idx <- which(get_visible())[idx]

                          
                          vals <- get_items(drop=FALSE)[idx, , drop=FALSE]
                          if(getWithDefault(drop, TRUE))
                            vals[, chosen_col, drop=TRUE]
                          else
                            vals
                        },
                        set_value=function(value, ...) {
                          "Set selected values by vector matching chosen.col, unless an integer"
                          block_handlers()
                          vals <- get_items(drop=TRUE)
                          if(is.numeric(value) && !is.numeric(vals))
                            ind <- value
                          else
                            ind <- match(value, vals)
                          ind <- ind[!is.na(ind)]
                          if(length(ind) == 0)
                            return() ## no match
                          set_index(ind)
                          unblock_handlers()                          
                        },
                        get_index = function(...) {
                          "Get index of selected rows or integer(0)"
                          idx <- get_selected()
                          idx <- which(get_visible())[idx]
                        },
                        set_index = function(value,...) {
                          "set selected values in value. integer(0) or 0L clears selection"
                          if(length(value) == 0 || value < 1)
                            widget$getSelection()$unselectAll() # clear selection if not >= 1
                          else {
                            ## selected wants actual for filtered
                            value <- match(value, which(get_visible()))
                            value <- value[!is.na(value)]
                            set_selected(as.integer(value) - 1L)
                          }
                        },
                        get_items = function(i, j, ..., drop=TRUE) {
                          DF <- get_model()[]
                          if(!is.data.frame(DF) && is.list(DF))
                            DF <- as.data.frame(DF, stringsAsFactors=FALSE)
                          
                          DF <- DF[, get_valid_columns(), drop=FALSE]
                          names(DF) <- get_names()
                          ## we possibly drop out some stuff
                          DF[i,j, drop=getWithDefault(drop, TRUE)]
                        },
                        set_items = function(value, i, j, ...) {
                          block_handlers()
                          on.exit(unblock_handlers())
                          if(missing(i) && missing(j)) {
                            ## set a new data frame model
                            ## we shove in ..visible for the last column q
                            if(!is(value, "data.frame")) {
                              if (is.vector(value))
                                value <- data.frame(Values=value, stringsAsFactors=FALSE)
                              else if(is.matrix(value))
                                value <- data.frame(value, stringsAsFactors=FALSE)
                            }
                            ## icons
                            if(!is.null(icon_col)) 
                              value[[icon_col]] <-  getStockIconByName(value[[icon_col]])
                            ## visible column
                            items <<- cbind(value, ..visible=rep(TRUE, nrow(value)))
                            model <- rGtkDataFrame(items)
                            filter <- model$filter()
                            filter$setVisibleColumn(ncol(items) -1L) # last column
                            clear_columns()
                            widget$setModel(filter)
                            make_columns()
                            set_names(names(value)[get_valid_columns()])
                          } else {
                            df_model <- get_model()
                            df_model[i,j] <- value ## hope case matches
                          }
                        },
                        set_focus = function(value) {
                          "If we can focus, do so, then raise"
                          if(value) {
                            widget$grabFocus()
                            widget$getWindow()$raise()
                          }
                        },
                        ## data store methods
                        get_length=function() {
                          get_dim()[2]
                        },
                        get_dim=function() {
                          "Return dim of view (not data frame which may have extra information)"
                          c(rows=dim(get_model())[1], columns=length(get_valid_columns()))
                        },
                        get_names=function() {
                          sapply(get_view_columns(), function(col) {
                            label <- col$getWidget()$getChild()
                            label$getLabel()
                          })
                        },
                        set_names =function(value) {
                          ## check length
                          m <- get_dim()[2]
                          if(length(value) != m)
                            return()
                         
                          f <- function(col, nm) {
                            label <- col$getWidget()$getChild()
                            label$setLabel(nm)
                          }
                          mapply(f, get_view_columns(), value)
                        },
                        get_visible=function() {
                          ## return last column in DF
                          DF <- get_model()
                          DF[, ncol(DF), drop=TRUE]
                        },
                        set_visible=function(value, ...) {
                          DF <- get_model()
                          value <- rep(value, length.out=nrow(DF))
                          DF[,ncol(DF)] <- value
                        },
                        set_size=function(value, ...) {
                          "set size also has possibility of column widths"
                          if(is.list(value)) {
                            col_widths <- value$column.widths
                            value$column.widths <- NULL
                            set_column_widths(col_widths)
                            value <- c(width=value$width, height=value$height) # make vector, not list
                          }
                          callSuper(value, ...)
                        },
                        set_column_widths=function(value) {
                          if(length(value) == get_dim()[2]) {
                            cols <-get_view_columns()
                            mapply(gtkTreeViewColumnSetMinWidth, cols, value)
                          }
                        },
                        ## Handlers
                        add_handler_changed=function(handler, action=NULL, ...) {
                          add_handler("row-activated", handler, action, ...)
                        },
                        add_handler_selection_changed=function(handler, action=NULL, ...) {
                          ## selection changed
                          if(is_handler(handler)) {
                            o <- gWidgets2:::observer(.self, handler, action)
                            invisible(add_observer(o, change_signal))
                            gSignalConnect(widget$getSelection(), "changed", function(self, ...) {
                              self$notify_observers(signal=change_signal, ...)
                            }, data=.self, user.data.first=TRUE)
                          }
                        },
                        add_handler_clicked=function(handler, action, ...) {
                          if(!is_handler(handler))
                            return()
                          o <- gWidgets2:::observer(.self, handler, action)
                          invisible(add_observer(o, "button-press-event"))
                        },
                        add_handler_double_clicked=function(handler, action, ...) {
                          ## There is an oddity here. When using row-activated it does as desired unless
                          ## we also have addHandlerChanged called in which case this is always called. So
                          ## we bypass and do button and mouse events as they arise
                          ## add_handler("row-activated", handler, action=action, ...)

                           if(!is_handler(handler))
                             return()
                           o <- gWidgets2:::observer(.self, handler, action)
                           invisible(add_observer(o, "2button-press-event"))
                        },
                        ##
                        hide_names=function(value) {
                          "adjust visibility of header"
                          widget$setHeadersVisible(!as.logical(value))
                        }

                        ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gdf.R"
##' @include GWidget.R
##' @include gmenu.R
##' @include dialogs.R
##' @include gtable.R
NULL

## TODO
## * handlers
## * column drag and drop
## * size override for passing in column sizes through a list.


##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gdf
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gdf guiWidgetsToolkitRGtk2
##' @S3method .gdf guiWidgetsToolkitRGtk2
.gdf.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                         items = NULL,
                    handler = NULL,action = NULL, container = NULL, ... ) {
  GDf$new(toolkit,
           items=items, 
           handler = handler, action = action, container = container, ...)
}



##' S3 generic to ensure we don't change data type when assigning into column
##'
##' @param x column values
##' @param value new value
##' @return coerced new value
ensure_type <- function(x, value) UseMethod("ensure_type")
ensure_type.default <- function(x, value) value
ensure_type.character <- function(x, value) as.character(value)
ensure_type.factor <- function(x, value) {x[length(x) + 1] <- value; tail(x, n=1)}
ensure_type.numeric <- function(x, value) as.numeric(value)
ensure_type.integer <- function(x, value) as.integer(value)
ensure_type.logical <- function(x, value) as.logical(value)


##' make a view column for the given type of variable
##'
##' @param x variable
##' @param self reference to ModelView object
##' @param model_idx 1-based index in model of data to represent
##' @param view_col optional view column to reuse
##' @return a gtkTreeViewColumn with data "n", and "id" to block editable id
add_editable_cell_renderer <- function(x, self, model_idx, view_col)  {

  ## Make column, set editable
  if(missing(view_col))
    view_col <- gtkTreeViewColumnNew()
  else
    view_col$clear()

  make_editable_cell_renderer(x, self, model_idx, view_col)
  
  event_box <- gtkEventBox()
  event_box$SetVisibleWindow(FALSE)
  label <- gtkLabel()
  event_box$add(label)
  event_box$setAboveChild(TRUE)         # gets events to box
  view_col$setWidget(event_box)
  

  view_col
}

## Make cell renderer for above. Dispatches on x
make_editable_cell_renderer <- function(x, self, model_idx, view_col) UseMethod("make_editable_cell_renderer")
make_editable_cell_renderer.default <- function(x, self, model_idx, view_col) {
  cr <- gtkCellRendererText()
  cr['editable'] <- TRUE
  cr$setData("editable", "editable")
  cr$setData("view_col", view_col)      # no lookup otherwise
  view_col$setResizable(TRUE)
  view_col$packStart(cr, TRUE)
  view_col$addAttribute(cr, "text", model_idx - 1L)
  ## make editable
  id <- gSignalConnect(cr,
                       signal="edited",
                       f=function(cr, path, newtext) {
                         visible <- self$get_visible()
                         i <- which(visible)[as.numeric(path) + 1]

                         view_col <- cr$getData("view_col")
                         j <- self$get_column_index(view_col)

                         self$cmd_set_cell(i, j, newtext)
                       })
  view_col$setData("n", model_idx)      # map to model
  view_col$setData("edit.id", id)       # use this to disable editing
}


make_editable_cell_renderer.factor <- function(x, self, model_idx, view_col) {
  cr <- gtkCellRendererCombo()
  model <- rGtkDataFrame(levels(x))
  cr['model'] <- model
  cr['text-column'] <- 0
  cr['editable'] <- TRUE
  cr$setData("editable", "editable")
  cr$setData("view_col", view_col)      # no lookup otherwise
  view_col$setResizable(TRUE)
  view_col$packStart(cr, TRUE)
  view_col$addAttribute(cr, "text", model_idx - 1L)
  ## make editable
  id <- gSignalConnect(cr,
                       signal="edited",
                       f=function(combo, path, newdata) {
                         visible <- self$get_visible()
                         i <- which(visible)[as.numeric(path) + 1]

                         view_col <- cr$getData("view_col")
                         j <- self$get_column_index(view_col)

                         self$cmd_set_cell(i, j, newdata) # toggle
                       })
  view_col$setData("n", model_idx)      # map to model
  view_col$setData("edit.id", id)       # use this to disable editing
}



make_editable_cell_renderer.logical <- function(x, self, model_idx, view_col) {
 
  cr <- gtkCellRendererToggle()
  cr['activatable'] <- TRUE
  cr$setData("editable", "activatable")
  cr$setData("view_col", view_col)      # no lookup otherwise
  
  view_col$setResizable(TRUE)
  view_col$packStart(cr, TRUE)
  view_col$addAttribute(cr, "active", model_idx - 1L)

  ## make editable
  id <- gSignalConnect(cr,
                       signal="toggled",
                       f=function(cr, path, data) {
                         visible <- self$get_visible()
                         i <- which(visible)[as.numeric(path) + 1]

                         view_col <- cr$getData("view_col")
                         j <- self$get_column_index(view_col)

                         self$cmd_set_cell(i, j, !self$get_cell(i, j)) # toggle
                       })
  view_col$setData("n", model_idx)      # map to model
  view_col$setData("edit.id", id)       # use this to disable editing

}



make_editable_cell_renderer.Date <- function(x, self, model_idx, view_col) {
  cr <- gtkCellRendererText()
  cr['editable'] <- TRUE
  cr$setData("editable", "editable")
  cr$setData("view_col", view_col)      # no lookup otherwise
  view_col$setResizable(TRUE)
  view_col$packStart(cr, TRUE)
  view_col$addAttribute(cr, "text", model_idx - 1L)
  view_col$setCellDataFunc(cr, function(vc, cr, model, iter, ...) {
    ## set cell value by formatting
    col <- self$get_column_index(cr$getData("view_col"))
    row <- as.numeric(model$getPath(iter)$toString()) + 1L
    val <- self$get_cell(row, col)
    cr["text"] <- format(val)
    
  })
  ## make editable
  id <- gSignalConnect(cr,
                       signal="edited",
                       f=function(cr, path, newtext) {
                         visible <- self$get_visible()
                         i <- which(visible)[as.numeric(path) + 1]

                         view_col <- cr$getData("view_col")
                         j <- self$get_column_index(view_col)
                         ## calls ensure_type to format
                         self$cmd_set_cell(i, j, newtext)
                       })
  view_col$setData("n", model_idx)      # map to model
  view_col$setData("edit.id", id)       # use this to disable editing
}

make_editable_cell_renderer.POSIXt <- make_editable_cell_renderer.Date

## This is a bit convoluted due to the command framework. To do
## something, say set a cell value we have 3 methods! One is a
## gWidgets methods (\code{set_items(i,j,value)}), this in turn calls
## a command with undo/redo support (\code{cmd_set_cell}), the
## command relies on the third method to actual set the cell value
## (\code{set_cell(i,j,value)}). To make matters worse, there is an
## issue defining one-off reference classes within a reference class
## when the \code{<<-} operator is involved. As such, we have a
## fourth place things may be defined -- in reference class
## definitions appearing after the one for \code{GDf}. Be warned,
## this is a maintenance issue.

GDfBase <- setRefClass("GDfBase",
                       contains="GWidget",
                       fields=list(
                         model="ANY",
                         store="ANY",
                         freeze_attributes="character", # one of FALSE, TRUE, "row", or "column"
                         cmd_stack="ANY",
                         cell_popup_id="ANY"
                         ),
                       methods=list(
                       set_frame=function(items) {
                         "Change data frame, update view, clear out stack"
                         clear_stack()
                         clear_view_columns()

                         ## if any row is all NA, then we set the class to numeric
                         for (nm in names(items)) {
                           if(all(is.na(items[nm]))) {
                             items[nm] <- rep(NA_real_, nrow(items))
                           }
                         }
                         
                         mod_items <- cbind(`_visible`=rep(TRUE, nrow(items)),
                                            `_deleted`=rep(FALSE, nrow(items)),
                                            `_rownames`=I(rownames(items)),
                                            items)
                         
                         model$setFrame(mod_items)
                         add_view_columns()
                       },
                       save_data=function(nm, where) {
                         assign(nm, get_frame(), where)
                         cmd_stack$clear()
                       },
                       ##
                       ## View column methods
                       ##
                       get_view_column=function(j) {
                         "Return view column in column j (1-based). Use j=0 for rownames column"
                         widget$getColumns()[[j + 1L]] # skip rownams
                       },
                       clear_view_columns=function() {
                         "Clear out all view columns from view"
                         sapply(rev(widget$getColumns()), widget$removeColumn)
                       },
                       add_view_columns=function() {
                         "Add view columns to treeview widget"
                         DF <- as.data.frame(model)

                         ## add row names column
                         view_col<- add_editable_cell_renderer(as.character(DF[[3]]), self=.self, model_idx=3)
                         cr <- view_col$getCellRenderers()[[1]]; cr['font'] <- "Bold"
                         widget$insertColumn(view_col, -1L)
                         ## add remaining columns
                         sapply(seq_along(DF[,-(1:3), drop=FALSE]), function(i) {
                           view_col <- add_editable_cell_renderer(DF[[i + 3L]], self=.self, model_idx=i + 3L)
                           widget$insertColumn(view_col, -1L)
                           if(!freeze_attributes %in% c("TRUE", "column"))
                             add_popup_to_view_col(view_col)
                         })
                         ## set names
                         set_names(names(DF)[-(1:3)]) # remove first 3!
                       },
                       ##
                       ## Get the data
                       ##
                       get_frame=function() {
                         "Get data frame from columns. Skips deleted rows, but returns non-visible ones"
                         columns <- widget$getColumns()[-1] # drop rownames
                         cols <- sapply(columns, function(vc) vc$getData("n"))
                         out <- model[not_deleted(),cols, drop=FALSE]
                         names(out) <- get_names()
                         rownames(out) <- make.unique(get_rownames())
                         out
                       },
                         ## DND
                         ## XXX This needs fleshing out
                         add_dnd_columns=function() {
                           ## Hack to add in drag and drop to columns
                           remove_popup_menu()
                           add_dnd_to_vc <- function(vc) {
                             vc$setClickable(TRUE)
                             btn <- vc$getWidget()$getParent()$getParent()$getParent()
                             label <- vc$getWidget()$getChild() 
                             gtkDragSourceSet(btn,
                                              start.button.mask=c("button1-mask", "button3-mask"),
                                              targets=widgetTargetTypes[["text"]],
                                              actions="copy")
                             gSignalConnect(btn, "drag-data-get", function(data, widget, contet, sel, ty, tm, ...) {
                               sel$setText(data$getLabel(), -1)
                             }, label, user.data.first=TRUE)
                           }

                           QT <- Map(add_dnd_to_vc, widget$getColumns())
                         },
                       ##
                       ## Column methods
                       ##
                       add_column=function(x, nm) {
                         "Add column to end of model, create new view column, set name to nm"
                         n <- get_dim()[2]
                         if(missing(nm))
                           nm <- sprintf("X%s", n)
                         frame <- as.data.frame(model)
                         frame[not_deleted(),ncol(frame) + 1] <- x
                         model$setFrame(frame)
                         model_n <- dim(model)[2]
                         view_col <- add_editable_cell_renderer(x, .self, model_n)
                         widget$insertColumn(view_col, -1)
                         add_popup_to_view_col(view_col)
                         
                         j <- get_column_index(view_col)
                         set_name(j, nm)

                         
                         model_n         # return
                       },
                       insert_column=function(j, model_idx, nm) {
                         "Insert column j with model number model_idx and name name"
                         DF <- as.data.frame(model)
                         view_col <- add_editable_cell_renderer(DF[[model_idx]], .self, model_idx)
                         view_col$getWidget()$getChild()$setLabel(nm)
                         widget$insertColumn(view_col, j)
                         add_popup_to_view_col(view_col)
                       },
                       remove_column=function(j) {
                         "Remove column from view. Keeps data in model. Returns name and index in model to undo"
                         column <- get_view_column(j)
                         old_nm <- get_name(j)
                         model_idx <- column$getData("n") # model_idx is 1-based
                         widget$removeColumn(column)
                         invoke_change_handler()
                         ## return info to reconstruct
                         invisible(list(nm=old_nm, model_idx=model_idx ))
                       },
                       move_column=function(from ,to) {
                         "Move a view column from j to i, shift others over. Does not effect model."
                         columns <- widget$getColumns()[] # includes rownames as 1, so no shift over
                         from_col <- columns[[from + 1L]]
                         to_col <- columns[[to]]
                         widget$moveColumnAfter(from_col, to_col)
                       },
                       hide_column=function(j, value) {
                         "Hide column j (view coordinates). Hiding column j does not remove it and j still refers to this column. That is view coordinates are different from what is in GUI"
                         column <- get_view_column(j)
                         column$setVisible(!as.logical(value))
                         invisible(!value)
                       },
                       unhide_column=function(j) {
                         column <- get_view_column(j)
                         column$setVisible(TRUE)
                       },
                       is_editable=function(j) {
                         column <- get_view_column(j)
                         cr <- column$getCellRenderers()[[1]]
                         cr[cr$getData("editable")]
                       },
                       block_editable_column=function(j) {
                         "Block that column j can be edited"
                         column <- get_view_column(j)
                         cr <- column$getCellRenderers()[[1]]
                         cr[cr$getData("editable")] <- FALSE
                       },
                       unblock_editable_column=function(j) {
                         "unblock that column j can be edited"
                         column <- get_view_column(j)
                         cr <- column$getCellRenderers()[[1]]
                         cr[cr$getData("editable")] <- TRUE
                       },
                       ##
                       ## Row methods
                       ##
                       hide_row=function(i,value=TRUE) {
                         "Hide row i, i refers to non-deleted rows. value if TRUE to hide, FALSE to unhide"
                         i <- map_i(i)
                         model[i,1] <<- !as.logical(value)
                         invisible(!value) # return opposite for command framework
                       },
                       remove_row=function(i, value, model_index=FALSE) {
                         "Delete row"
                         ## we don't actually delete, we just make not visible and deleted.
                         if(!model_index)
                           i <- map_i(i)
                         model[i,1] <<- !as.logical(value)
                         model[i,2] <<- as.logical(value)
                         invisible(i)
                       },
                       unremove_row=function(model_i) {
                         "Un delete row model_i."
                         model[model_i,1] <<- TRUE # show it
                         model[model_i,2] <<- FALSE
                       },
                       insert_row=function(i, value) {
                         "Insert new row after position i, i=0:nrow"
                         ## we insert row into model. How depends on what i is.
                         DF <- as.data.frame(model)
                         if(i == 0) {
                           ## first
                           new_DF <- DF[c(1, seq_len(nrow(DF))), ]
                           new_i <- 1
                         } else if(i >= get_dim()[1]) {
                           i <- get_dim()[1] # in case bigger
                           ## end
                           new_DF <- DF[c(seq_len(nrow(DF)), 1), ]
                           new_i <- nrow(new_DF)
                         } else {
                           ## middle
                           ii <- map_i(i)
                           new_DF <- DF[c(1:ii, 1, (ii+1):nrow(DF)), ]
                           new_i <- ii + 1
                         }
                         ## clear
                         n <- ncol(new_DF)
                         new_DF[new_i,] <- lapply(1:n, function(i) NA)
                         new_DF[new_i, 1:3] <- list(TRUE, FALSE, "")
                         
                         if(!missing(value)) {
                           ind <- sapply(widget$getColumns()[-1], function(vc) vc$getData("n"))
                           new_DF[new_i, ind] <- value
                         } 

                         model$setFrame(new_DF)
                         return(new_i)   # new column in model coordinates
                       },
                       ## names
                       set_view_column_name=function(column, value) {
                         j <- get_column_index(column)
                         old_nm <- get_name(j)
                         column$getWidget()$getChild()$setLabel(value)
                         return(old_nm)
                       },
                       set_name = function(j, value) {
                         "Set view column's name"
                         old_nm <- get_name(j)
                         column <- get_view_column(j)
                         column$getWidget()$getChild()$setLabel(value)
                         invoke_change_handler()
                         return(old_nm)
                       },
                       get_name=function(j) {
                         column <- get_view_column(j)
                         column$getWidget()$getChild()$getLabel()
                       },
                       hide_names=function(value) {
                         "Toggle display of names by logical values"
                         widget$setHeadersVisible(as.logical(value))
                       },
                       set_row_name=function(i, value) {
                         i <- map_i(i)
                         old_value <- model[i, 3L]
                         model[i, 3L] <<- value
                         invisible(old_value)
                       },
                       hide_row_names=function(value) {
                         "Toggle display of row names by logical value"
                         hide_column(0, value)
                       },
                       ##
                       ## mappings between view columns and model
                       ##
                       get_column_index=function(view_col) {
                         "Get view column index from view column"
                         columns <- widget$getColumns()[-1] # no reownames
                         Filter(function(i) identical(columns[[i]], view_col), seq_along(columns)) 
                       },
                       map_j=function(j) {
                         "get column in model from j"
                         column <- get_view_column(j) # skip rownames
                         n <- column$getData("n") # 0-based
                         n
                       },
                       not_deleted=function() {
                         "Return indices of non deleted model rows"
                         which(!model[,2L])
                       },
                       map_i=function(i) {
                         "Return model index from i (possibl sorted, removed, ...)"
                         ## i is in order, but we skip over deleted -- but not filtered
                         not_deleted()[i]
                       },
                       ##
                       ## Values by cell, column
                       ##
                       get_cell=function(i,j) {
                         "Get value in cell i,j using view coordinates"
                         model[map_i(i), map_j(j)]
                       },
                       set_cell=function(i, j, value) {
                         "set cell, i, j in view coordinates (including hidden). Return old_value"
                         n <- map_j(j)
                         old_value <- model[map_i(i), n]
                         model[map_i(i), n] <<- ensure_type(model[,n], value)
                         old_value
                       },
                       get_column_value=function(j) {
                         "Get data in model for jth column in view coordinates"
                         model[not_deleted(), map_j(j)]
                       },
                       ##
                       ## Selection methods. From gtable
                       ##
                       get_selected=function() {
                         "Get selected indices or numeric(0)"
                         sel_model <- widget$getSelection()
                         x <- sapply(sel_model$getSelectedRows()$retval, gtkTreePathToString)
                         if(is.null(x))
                           x <- integer(0)
                         else
                           x <- as.numeric(x) + 1L
                         seq_len(nrow(model))[model[,1]][x] # not deleted
                       },
                       set_selected=function(ind) {
                         "Set selected rows by index"
                         old_ind <- get_selected()
                         ind <- seq_len(nrow(model))[!model[,2]][ind]
                         sel_model = widget$getSelection()
                         block_handlers()
                         sel_model$unselectAll()
                         lapply(ind, function(i) {
                           sel_model$selectPath(gtkTreePathNewFromString(i-1))
                         })
                         
                         unblock_handlers()
                       },
                         set_selectmode=function(mode=c("none", "single", "browse", "multiple")) {
                           sel = widget$getSelection()
                           sel$setMode(match.arg(mode))
                         },
                       ##
                       ## Popup menu methods. From gtable (should be a subclass)
                       ##
                       default_popup_menu=function(view_col) {
                         "Provide default popup menu (passed to gmenu(..., popup=TRUE))"
                         j <- get_column_index(view_col)
                         x <- get_column_value(j)
                         nm <- get_name(j)

                         ## intercept row names
                         types <- c("other", "character", "factor", "numeric", "logical")
                         tmp <- function(x) UseMethod("tmp")
                         tmp.default <- function(x) ""
                         tmp.numeric <- function(x) "numeric"
                         tmp.factor <- function(x) "factor"
                         tmp.character <- function(x) "character"
                         tmp.logical <- function(x) "logical"

                         actions <- list(
                                         gaction("Rename column", handler=function(h,...) {
                                           out <- ginput(gettext("New column names:"), nm, title=gettext("Rename column"), parent=.self)
                                           if(nchar(out))
                                             cmd_set_column_name(j, out)
                                         }),
                                         gseparator(),
                                         gaction("Insert column...", handler=function(h,...) {
                                           ## need x, nm
                                           x <- character(get_dim()[1])
                                           nm <- "Replace me"
                                           cmd_insert_column(x, nm, j)
                                         }),
                                         gaction("Delete column", handler=function(h,...) {
                                           cmd_remove_column(j)
                                         }),
                                         ## gaction("Hide column", handler=function(h,...) {
                                         ##   cmd_hide_column(j)
                                         ## }),
                                         gseparator(),
                                         ## Coerce class of object
                                         gradio(types, selected=getWithDefault(match(tmp(x), types), 1L), handler=function(h,...) {
                                           ind <- svalue(h$obj, index=TRUE)
                                           if(ind > 1) 
                                             cmd_coerce_column(j, get(sprintf("as.%s", types[ind])))
                                         }),
                                         gseparator(),
                                         gaction("Edit factor levels...", handler=function(h, ...) {
                                           collapseFactor <- function(f, parent = NULL) {
                                             out <- character()
                                             w <- gbasicdialog("Edit factor levels", parent = parent,
                                                               handler = function(h,...) {
                                                                 new_f <- relf$get_value()
                                                                 assign("out", factor(new_f), inherits=TRUE)
                                                               })
                                             size(w) <- c(600, 400)
                                             
                                             g <- ggroup(cont = w)
                                             relf <- CollapseFactor$new(f, cont = g)
                                             visible(w, set = TRUE)
                                             out
                                           }
                                           out <- collapseFactor(x)
                                           if(length(out)) {
                                             cmd_replace_column(out, j)
                                           }
                                           
                                         }),
                                         gseparator(),
                                         gcheckbox("Editable", checked=is_editable(j), handler=function(h,...) {
                                           if(svalue(h$obj))
                                             unblock_editable_column(j)
                                           else
                                             block_editable_column(j)
                                         }),
                                         gseparator(),
                                         gaction("Apply function ...", handler=function(h,...) {
                                           w <- gbasicdialog(gettext("Apply a function to values in the column"), parent=.self, handler=function(h,...) {
                                             val <- svalue(txt)
                                             new_x <- eval(parse(text=val), envir=list(x=x))
                                             if(is.vector(new_x))
                                               cmd_insert_column(new_x)
                                             else
                                               galert(gettext("Expression did not return a vector"), parent=.self)
                                           })
                                           txt <- gtext("sapply(x, function(i) {\n\n})", cont=w)
                                           visible(w, TRUE)
                                         })
                                         )
                         enabled(actions[[8]]) <- is.factor(x)
                         actions
                       },
                       add_popup_menu=function(menulist) {
                         f <- function(...) menulist
                         add_popup(f)
                       },
                       add_popup=function(menu_fun=NULL) {
                         "Add a popup menu to the columns. Function should generate list of actions, ..."
                         
                         
                         sapply(widget$getColumns()[-1], function(view.col) {
                           add_popup_to_view_col(view.col)
                         })
                       },
                       add_popup_to_view_col=function(view.col, menu_fun) {
                         if(freeze_attributes %in% c("TRUE", "column")) {
                           return()     # no popup menu if frozen
                         }
                         if(missing(menu_fun))
                           menu_fun <- .self$default_popup_menu

                         view.col$setClickable(TRUE)
                         event_box <- view.col$getWidget()                          
                         btn <- event_box$getParent()$getParent()$getParent()
                         id <- gSignalConnect(btn, "button-press-event", f=function(w, e, data, ...) {
                           if(isRightMouseClick(e)) {
                             popup <- gmenu(menu_fun(data), popup=TRUE, toolkit=toolkit)
                             ## This is a *real* hack, as the following doesn't
                             ## work when I use event_box. NOt sure why
                             ## not, seems like the right combination of
                             ## arguments is given
                             popup$widget$popup(button=e$button, activate.time=e$time)
                           }
                           FALSE
                         }, data=view.col)
                         btn$setData("popup_id", id)
                       },
                       remove_popup_menu=function() {
                         "remove popup menu from column headers"
                         sapply(widget$getColumns(), function(view.col) {
                           view.col$setClickable(FALSE)
                           btn <- view.col$getWidget()$getParent()$getParent()$getParent()
                           if(!is.null(id <- btn$getData("popup_id")))
                             gSignalHandlerDisconnect(btn, id)
                         })
                       },
                       default_cell_popup_menu=function() {
                         ## returns a function of i,j which produces actions for a popup menu
                         ## j=0 when rownames column
                         f <- function(self, i, j) {
                           if(j == 0) {
                             ## rownames popup
                             actions <- list(
                                             gaction("Insert row", handler=function(...) {
                                               self$cmd_insert_row(i)
                                             }),
                                             gaction("Delete row", handler=function(...) {
                                               self$cmd_remove_row(i)
                                             })#,
                                             ## gaction("Hide row", handler=function(...) {
                                             ##   self$cmd_hide_row(i)
                                             ## })
                                             )
                           } else {
                             ## No idea what to put here...
                             actions <- list(
                                             gaction("cell popup")
                                             )
                           }
                         }
                         return(f)
                       },
                       add_cell_popup=function(menu_fun) {
                         "Add cell popup, pass in function to produce menu or uses default"
                         if(missing(menu_fun))
                           menu_fun <- default_cell_popup_menu()

                         id <- gSignalConnect(widget, "button-press-event", f=function(w, e, self) {
                           if(isRightMouseClick(e)) {
                             path <- w$getPathAtPos(e$x, e$y)
                             if(!path$retval) # no path
                               return(FALSE)
                             i <- visible <- self$get_visible()
                             i <- which(visible)[as.numeric(path$path$toString()) + 1]
                             j <- self$get_column_index(path$column)
                             if(length(j) == 0) j <- 0
                             ## Can have popup on cells, but right now don't know what to put there
                             if(j == 0) {
                               popup <- gmenu(menu_fun(self, i, j), popup=TRUE, toolkit=toolkit)
                               popup$widget$popup(button=e$button, activate.time=e$time)
                             }
                           }
                           FALSE
                         }, data=.self)
                         cell_popup_id <<- id
                       },
                       remove_cell_popup=function() {
                         "Remove cell popup"
                         gSignalHandlerDisconnect(widget, cell_popup_id)
                       },
                       ##
                       ## Main GWidget interface. Need gWidgets (svalue) and matrix interface
                       ##
                       get_dim=function() {
                         "size of displayed data"
                         ncols <- length(widget$getColumns()) - 1L # no rownames
                         nrows <- length(model[not_deleted(),1])
                         c(rows=nrows, cols=ncols)
                       },
                       get_length=function() {
                         get_dim()[2]
                       },
                       get_value=function(drop=TRUE, ...) {
                         ind <- get_selected()
                         if(length(ind) == 0)
                           return(NULL)  # ?? what is right?
                         
                         DF <- get_frame()
                         if(drop)
                           DF[ind, 1]
                         else
                           DF[ind,]
                       },
                       set_value=function(value, ...) {

                       },
                       get_index=function(...) {
                         get_selected()
                       },
                       set_index=function(value, ...) {
                         set_selected(value)
                       },
                       get_items=function(i,j, ...,drop=TRUE) {
                         x <- get_frame()
                         x[i,j, ..., drop=drop]
                       },
                       set_items=function(value, i, j, ...) {
                         "Replace part of data: whole thing, by column, by cell. By row?"
### XXX Need checks on i,j bounds not exceeding. Need to call insert_column, insert_row otherwise
                         
                         if(missing(i) && missing(j)) {
                           if(!is.data.frame(value))
                             value <- data.frame(value, stringsAsFactors=FALSE)
                           set_frame(value)
                         } else if(missing(i)) {
                           ## replace column by column
                           if(is.vector(value))
                             cmds <- list(cmd_replace_column(value, j))
                           else
                             cmds <- lapply(seq_along(j), function(i) cmd_replace_column(value[i], j[i], add=FALSE))
                           cmd_stack$add(gWidgets2:::CommandList$new(lst=cmds))
                         } else if(missing(j)) {
                           ## XXX need to add this row by row!
                           value <- as.data.frame(value)
                           sapply(seq_along(value), function(col) .self$set_items(value[,row], i, col))
                         } else {
                           if(length(i) == 1) {
                             value <- rep(value, length=length(j)) # recyle
                             cmd_list <- lapply(seq_along(j), function(jj) cmd_set_cell(i, j[jj], value[jj], add=FALSE))
                           } else if(length(j) == 1) {
                             value <- rep(value, length=length(i)) # recyle
                             cmd_list <- lapply(seq_along(i), function(ii) cmd_set_cell(i[ii], j, value[ii], add=FALSE))                                             } else {
                               ## no recycling
                               if(length(i) != nrow(value) || length(j) != ncol(value))
                                 stop(gettext("value is not of correct dimensions for indices"))
                               cmd_list <- lapply(seq_len(length(i) * length(j)), function(x) NULL)
                               ctr <- 1
                               for(ii in seq_along(i))
                                 for(jj in seq_along(j)) {
                                   cmd_list[[ctr]] <- cmd_set_cell(i[ii], j[jj], value[i[ii], j[jj]], add=FALSE)
                                   ctr <- ctr + 1
                                 }
                             }
                           cmd_stack$add(gWidgets2:::CommandList$new(lst=cmd_list))
                         }
                       },
                       get_names=function() {
                         sapply(widget$getColumns()[-1], function(vc) vc$getWidget()$getChild()$getLabel())
                       },
                       set_names=function(value) {
                         "Set the names of each column"
                         ## modify when using widget, not default
                                        #f <- function(vc, nm) vc$getWidget()$getChild()$setLabel(nm)
                                        #mapply(f, widget$getColumns()[-1], value)
                         cmd_set_column_names(value)
                       },
                       get_rownames=function() {
                         model[not_deleted(), 3]       # fixed
                       },
                       set_rownames=function(value) {
                         if(length(value) != length(not_deleted()))
                           return()      # wrong length
                         old_names <- get_rownames()
                         model[not_deleted(),3] <<- value
                         invisible(old_names)
                       },
                       get_dimnames=function() {
                         list(rownames=get_rownames(), colnames=get_names())
                       },
                       set_dimnames=function(value) {
                         XXX()
                       },
                       get_visible=function() {
                         "Return which rows are visible"
                         model[not_deleted(),1L]
                       },
                       set_visible=function(value) {
                         ## don't update
                         block_handlers()
                         if(length(value) == length(not_deleted()))
                           model[not_deleted(), 1L] <<- as.logical(value)
                         unblock_handlers()
                       },
                       get_editable=function(j) {
                         is_editable(j)
                       },
                       set_editable=function(value, j, ...) {
                         "Make a column editable or not."
                         if(value)
                           unblock_editable_column(j)
                         else
                           block_editable_column(j)
                       },
                       ##
                       ## Handler code
                       ##
                       handler_widget=function() {
                         ## for add_handler_changed
                         model
                       },
                       add_handler_clicked=function(handler, action=NULL, ...) {
                         ## put this on tree view, we used handler_widget for the model
                         signal <- "button-press-event"
                         if(is_handler(handler)) {
                           o <- gWidgets2:::observer(.self, event_decorator(handler), action)
                           invisible(add_observer(o, signal))
                           gSignalConnect(widget, signal, function(...) {
                             .self$notify_observers(signal=signal, ...)
                           })
                           connected_signals[[signal]] <<- TRUE
                         }
                       },
                       add_handler_column_clicked=function(handler, action=NULL, ...) {
                         XXX()
                       },
                       add_handler_column_double_click=function(handler, action=NULL, ...) {
                         XXX()
                       },
                       add_handler_column_right_click=function(handler, action=NULL, ...) {
                         XXX()
                       },
                       ##
                       ## Command infrastructure
                       ##
                       clear_stack=function() cmd_stack$clear(),
                       can_undo=function() cmd_stack$can_undo(),
                       can_redo=function() cmd_stack$can_do(),
                       undo=function() cmd_stack$undo(),
                       redo=function() cmd_stack$redo(),
                       ##
                       ## Commands with undo support
                       ## 
                       cmd_set_cell=function(i, j, value, add=TRUE) {
                         "Set cell i,j (in view indices) to value"
                         if(length(j)) {
                           cmd <- gWidgets2:::Command$new(receiver=.self, meth="set_cell",i=i, j=j, value=value)
                         } else {
                           ## setting row name
                           cmd <- gWidgets2:::Command$new(receiver=.self, meth="set_row_name",i=i, value=value)
                         }
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       ## Column commands. 
                       cmd_insert_column=function(x, nm, j, add=TRUE) {
                         "Insert values from x into j"
                         if(missing(nm))
                           nm <- gettext("Replace me")
                         if(missing(j))
                           j <- get_dim()[2]
                         cmd <- InsertColumn$new(.self, meth="", x=x, nm=nm, j=j)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_replace_column=function(x, j, add=TRUE) {
                         "Replace values in column j with x"
                         cmd <- ReplaceColumn$new(.self, meth="", x=x, j=j)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_remove_column=function(j, add=TRUE) {
                         "remove column j"
                         cmd <- RemoveColumn$new(.self, meth="", j=j)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_hide_column=function(j, add=TRUE) {
                         "hide column j"
                         ## do command
                         cmd <-  gWidgets2:::Command$new(receiver=.self, meth="hide_column", j=j, value=TRUE)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_unhide_column=function(j, add=TRUE) {
                         "Show hidden column j"
                         ## do command
                         cmd <- setRefClass("UnhideColumn",
                                            contains="Command",
                                            methods=list(
                                              do=function() receiver$unhide_column(params$col),
                                              undo=function() receiver$hide_column(params$col)
                                              ))$new(.self, meth="", col=j)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_coerce_column=function(j, coerce_with, add=TRUE) {
                         "Coerce column using coerce_with function, e.g. as.integer or as.character"
                         x <- get_column_value(j)
                         x <- coerce_with(x)
                         cmd <- ReplaceColumn$new(.self, meth="", j=j, x=x)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_set_column_name=function(j, nm, add=TRUE) {
                         cmd <- gWidgets2:::Command$new(receiver=.self, meth="set_name", j=j, value=nm)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_set_column_names=function(value, add=TRUE) {
                         if(length(value) != get_dim()[2])
                           stop(gettext("Wrong length names"))
                         cmds <- lapply(seq_along(value), function(j) cmd_set_column_name(j, value[j], add=FALSE))
                         cmdlist <- gWidgets2:::CommandList$new(lst=cmds)
                         if(add)
                           cmd_stack$add(cmdlist)
                         invisible(cmdlist)
                       },
                       ## row commands
                       cmd_insert_row=function(i, nm, add=TRUE) {
                         if(missing(nm))
                           nm <- ""
                         cmd <- InsertRow$new(.self, meth="", i=i, nm=nm)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_remove_row=function(i, add=TRUE) {
                         cmd <- RemoveRow$new(.self, meth="", i=i)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_hide_row=function(i, add=TRUE) {
                         cmd <- gWidgets2:::Command$new(.self, meth="hide_row", i=i, value=TRUE)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       },
                       cmd_unhide_row=function(i, add=TRUE) {
                         cmd <- gWidgets2:::Command$new(.self, meth="hide_row", i=i, value=FALSE)
                         if(add)
                           cmd_stack$add(cmd)
                         invisible(cmd)
                       }

                       ))


##' For \code{RGtk2}, a GDf object has several methods defined for it
##' that are toolkit specific, but may be useful. For example, the
##' columns may be made editable or non editable
##' (\code{block_editable_column} and \code{unblock_editable_column})
##' (accessed through \code{editable<-}); the headers can be
##' hidden/shown through the method \code{hide_names(boolean)}; the
##' rownames can be hidden/shown through themethod
##' \code{hide_row_names(boolean)}; the popup menus for the headers
##' can be removed (\code{remove_popup_menu}) and customized
##' (\code{add_popup}); similarly the cell popup can be
##' (\code{remove_cell_popup} and \code{add_cell_popup}).
##'
##' Passing in a value \code{freeze_attributes = TRUE} will make it so
##' there are no menu items to resize frame, change variable types,
##' relabel factors, .... Values of \code{"row"} or \code{"column"}
##' will remove popup menus just for the row or columns.
##' 
##' @rdname gWidgets2RGtk2-package
GDf <- setRefClass("GDf",
                   contains="GDfBase",
                   methods=list(
                     initialize=function(toolkit, items, name=deparse(substitute(df)),
                       handler=NULL, action=NULL,
                       container=NULL,
                       ...) {
                       
                       model <<- rGtkDataFrame()
                       store <<- model$filter()
                       store$setVisibleColumn(0L)
                       
                       widget <<- gtkTreeView()
                       widget$setModel(store)

                       ## make pretty XXX shade, ...
                       widget$setRulesHint(TRUE)
                       widget$setGridLines(GtkTreeViewGridLines['both'])
                       ## block is scrolled window
                       block <<- gtkScrolledWindow()
                       block$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                       block$add(widget)

                       ## command stack
                       cmd_stack <<- gWidgets2:::CommandStack$new()

                       ## initialize fields
                       initFields(default_expand=TRUE,
                                  default_fill=TRUE,
                                  change_signal="row-changed",
                                  freeze_attributes = as.character(getWithDefault(list(...)$freeze_attributes, FALSE))
                                  )

                       if(!is.data.frame(items))
                         items <- data.frame(items, stringsAsFactors=FALSE)
                       set_frame(items)

                       ## adjust if we should freeze attributes
                       if(freeze_attributes %in% c("TRUE", "row")) {
                         set_editable(FALSE, 0) # don't edit row names
                       }
                       if(!freeze_attributes %in% c("TRUE", "row")) {
                         ## menus only good once realized
                         gSignalConnect(widget, "realize", f=function(...) .self$add_cell_popup())
                       }

                       

                       
                       add_to_parent(container, .self, ...)
                       
                       ##handler_id <<- add_handler_changed(handler, action)
                       
                       callSuper(toolkit)
                     }
                     ))


## Some commands defined as separate classes. Put here, not inline as
## Issue here with <<- within command
## These are not exported or documented.

ReplaceColumn <- setRefClass("ReplaceColumn",
                             contains="Command",
                             methods=list(
                               do=function() {
                                j <- params$j
                                params$old_n <<- receiver$map_j(j)
                                #
                                x <- params$x
                                params$nm <<- receiver$get_name(j)
                                receiver$add_column(x, params$nm)
                                params$new_n <<- receiver$get_dim()[2] 
                                params$new_index <<- ncol(receiver$model) # new model index
                                receiver$remove_column(j)
                                receiver$move_column(params$new_n - 1L, j)

                               },
                               undo=function() {
                                 DF <- as.data.frame(receiver$model)
                                 n <- params$old_n
                                 add_editable_cell_renderer(DF[[n]], self=receiver, model_idx=n, receiver$get_view_column(params$j))
                                 receiver$set_name(params$j, params$nm)
                               },
                               redo=function() {
                                 DF <- as.data.frame(receiver$model)
                                 n <- params$new_index
                                 add_editable_cell_renderer(DF[[n]], self=receiver, model_idx=n, receiver$get_view_column(params$j))
                                 receiver$set_name(params$j, params$nm)
                               }
                               ))

InsertColumn <- setRefClass("InsertColumn",
                            contains="Command",
                            methods=list(
                              do=function() {
                                n <- receiver$add_column(params$x, params$nm)
                                params$model_idx <<- n
                                receiver$move_column(receiver$get_dim()[2], params$j + 1) # to right
                              },
                              undo=function() {
                                receiver$remove_column(params$j + 1)
                              },
                              redo=function() {
                                ## adds another column, not sure why
                                receiver$insert_column(params$j + 1, params$model_idx, params$nm)
                              }
                              ))

RemoveColumn <- setRefClass("RemoveColumn",
                            contains="Command",
                            fields=list(
                              "model_idx"="numeric"
                              ),
                            methods=list(
                              do=function() {
                                out <- receiver$remove_column(params$j) ## nm, model_idx
                                params$nm <<- out$nm; params$model_idx <<- out$model_idx
                              },
                              undo=function() {
                                receiver$insert_column(params$j, params$model_idx, params$nm)
                              },
                              redo=function() do()
                              ))

InsertRow <- setRefClass("InsertRow",
                         contains="Command",
                         fields=list(
                           row_num="ANY"
                           ),
                         methods=list(
                           do=function() {
                             row_num <<- receiver$insert_row(params$i)
                             receiver$set_row_name(row_num, params$nm)
                           },
                           undo=function() {
                             receiver$remove_row(row_num, TRUE, model_index=TRUE)
                           },
                           redo=function() {
                             receiver$unremove_row(row_num)
                           }
                           ))

RemoveRow <- setRefClass("RemoveRow",
                         contains="Command",
                         fields=list(
                           model_index="ANY"
                           ),
                         methods=list(
                           do=function() {
                             model_index <<- receiver$map_i(params$i)
                             receiver$remove_row(model_index, TRUE, model_index=TRUE)
                           },
                           undo=function() {
                             receiver$unremove_row(model_index)
                           },
                           redo=function() do()
                           ))


## ### Factor editor

## CollapseFactor <- setRefClass("CollapseFactor",
##                               fields = list(
##                                old = "ANY",
##                                widget = "ANY"
##                                ),
##                              methods = list(
##                                initialize = function(fac, cont = gwindow(), ...) {
##                                  old <<- as.character(fac)
##                                  make_gui(cont)
##                                  callSuper()
##                                },
##                                make_gui =  function(cont) {
##                                  group <- gpanedgroup(cont = cont)
##                                  levs <- sort(unique(as.character(old)))
##                                  DF <- data.frame(original = levs,
##                                                   new = levs, stringsAsFactors = FALSE)
##                                         #
##                                  widget <<- tbl <- gtable(DF, cont = group,  multiple = TRUE)
##                                  size(tbl) <- c(300, 200)
##                                         #
##                                  nested_group <- ggroup(cont = group, horizontal = FALSE)
##                                  instructions <- gettext(paste(
##                                    "Select a one or more levels.",
##                                    "Enter a new label in the text box.",
##                                    "If there is one level selected, it will be renamed.",
##                                    "If more, they will be collapsed and renamed.",
##                                    sep="\n"))
##                                         #
##                                  glabel(instructions, cont = nested_group)
## #                                 factor_edit <- gcombobox(levs, selected = 0, editable = TRUE, 
## #                                                        cont = nested_group)
##                                  factor_edit <- gedit("", cont=nested_group)
## #                                 factor_edit[] <- levs
##                                  enabled(factor_edit) <- FALSE
##                                         #
##                                  addHandlerSelectionChanged(widget, function(h,...) {
##                                    ind <- svalue(widget, index = TRUE)
##                                    enabled(factor_edit) <- (length(ind) > 0)
##                                    if (length(ind) > 0) {
##                                      blockHandler(factor_edit)
##                                      svalue(factor_edit) <- svalue(widget)
##                                      unblockHandler(factor_edit)
##                                    }
##                                  })
##                                  ##
##                                  factor_edit_change_handler =  function(h,...) {
##                                    ind <- svalue(tbl, index = TRUE)
##                                    if(length(ind) == 0 || ind == 0L)  {
##                                      return()
##                                    }
##                                         #
##                                    tbl[ind,2] <- svalue(factor_edit)
## #                                   svalue(tbl, index = TRUE) <- 0
##                                    blockHandler(factor_edit)
## #                                   factor_edit[] <- sort(unique(tbl[,2]))
## #                                   svalue(factor_edit) <- ""
##                                    unblockHandler(factor_edit)
##                                  }
##                                  addHandlerChanged(factor_edit, handler=function(h,...) {
##                                    blockHandler(factor_edit)
##                                    factor_edit_change_handler(h,...)
##                                    svalue(tbl, index=TRUE) <- 0
##                                    focus(tbl) <- TRUE
##                                    unblockHandler(factor_edit)
##                                  })
##                                  addHandlerKeystroke(factor_edit, handler =factor_edit_change_handler)
##                                  addHandlerBlur(factor_edit, handler=function(h,...) {
##                                    svalue(tbl, index = TRUE) <- 0
##                                    svalue(h$obj) <- ""
##                                  })
##                                },
##                                get_value = function() {
##                                  "Return factor with new levels"
##                                  old_levels <- widget[,1]
##                                  new_levels <- widget[,2]
##                                  new <- old
##                                  for(i in seq_along(old_levels)) # one pass
##                                    new[new == old_levels[i]] <- new_levels[i]
##                                  factor(new)
##                                }
##                                ))

CollapseFactor <- setRefClass("CollapseFactor",
                              fields = list(
                                old = "ANY",
                                cur_reference_level="ANY",
                                widget = "ANY",
                                cur_child = "ANY"
                                ),
                             methods = list(
                               initialize = function(fac, cont = gwindow(), ...) {
                                 old <<- fac
                                 cur_reference_level <<- levels(fac)[1]

                                 make_gui(cont)
                                 callSuper()
                               },
                               make_gui =  function(cont) {
                                 
                                 directions <- "
Adjust levels of a factor.

One can add a level through the 'Add' button.
Toggle if ordered with checkbox.
Select level to rename, make reference level, or
reorder, as appropriate.
Select levels to collapse.
"
                                 

                                 ## adjust these properties during dialog
                                 


                                 g <- gpanedgroup(container=cont, expand=TRUE)
                                 
                                 lg <- gvbox(container=g, fill="y")
                                 rg <- ggroup(container=g, expand=TRUE, fill="both")
                                 
                                 ## fill left group with table
                                 cur_levels <- gtable(levels(old), container=lg,
                                                      multiple=TRUE,
                                                      expand=TRUE, fill="y")
                                 size(cur_levels) <- c(width=200, height=400)
                                 names(cur_levels) <- "Levels"
                                 cur_levels$remove_popup_menu()

                                 bg <- ggroup(cont=lg)
                                 add_level <- gbutton("add", cont=bg, handler=function(h,...) {
                                   add_level_dialog(g)
                                 })
                                 tooltip(add_level) <- gettext("Add a new level to factor")
                                 
                                 is_ordered <- gcheckbox("Ordered", container=bg, checked=is.ordered(f))
                                 tooltip(is_ordered) <- gettext("Toggle if factor is ordered")
                                 
                                 
                                 ## Fill right group
                                 cur_child <<- gvbox(container=rg, expand=TRUE)
                                 glabel(directions, cont=cur_child, anchor=c(-1,0))
                                 
                                 ## adjust size after
                                 addHandler(g, "map", function(...) {
                                   svalue(g) <- 0.2
                                 })
                                 
                                 
                                 ## show different things based on selection...
                                 none_selected <- function() {
                                   delete(rg, cur_child)
                                   cur_child <<- gvbox(container=rg, expand=TRUE)
                                   glabel("Directions...", cont=cur_child, anchor=c(-1, 0))
                                 }
                                 
                                 one_selected <- function() {
                                   ## if one_is selected
                                   delete(rg, cur_child)
                                   cur_child <<- gvbox(container=rg, expand=TRUE)
                                   
                                   ## offer to relabel
                                   glabel(gettext("Relabel:"), container=cur_child, anchor=c(-1,0))
                                   rename_level <- gedit(svalue(cur_levels),
                                                         container=cur_child)
                                   gseparator(container=cur_child)
                                   
                                   ## give choice of making ordered, or adjusting order
                                   if(svalue(is_ordered)) {
                                     bg <- ggroup(cont=cur_child)
                                     move_up <- gbutton("up", cont=bg, handler=function(h,...) {
                                       ind <- svalue(cur_levels, ind=TRUE)
                                       cur <- cur_levels[]
                                       cur[c(ind-1,ind)] <- cur[c(ind, ind-1)]
                                       ## adjust factor
                                       old <<- factor(old, levels=cur)
                                       ## adjust GUI
                                       cur_levels[] <- cur
                                       svalue(cur_levels) <- ind - 1

                                       selection_changed()
                                     })
                                     move_down <- gbutton("down", cont=bg, handler=function(h,...) {
                                       ind <- svalue(cur_levels, ind=TRUE)
                                       cur <- cur_levels[]
                                       cur[c(ind,ind + 1)] <- cur[c(ind+1, ind)]
                                       ## adjust factor
                                       old <<- factor(old, levels=cur)
                                       ## adjust GUI
                                       cur_levels[] <- cur
                                       svalue(cur_levels) <- ind + 1

                                       selection_changed()
                                     })
                                     tooltip(move_up) <- gettext("Move selected level up in the order")
                                     tooltip(move_down) <- gettext("Move selected level down in the order")
                                     
                                     
                                     cur_ind <- svalue(cur_levels, ind=TRUE)
                                     nlevs <- length(cur_levels[])
                                     
                                     enabled(move_up) <- cur_ind > 1
                                     enabled(move_down) <- cur_ind < nlevs
                                   } else {
                                     ## can make ordered *or* make reference level
                                     bg <- ggroup(container=cur_child)
                                     ref_button <- gbutton("Set as reference", cont=bg, handler=function(h,...) {

                                       ind <- svalue(cur_levels, index=TRUE)
                                       if (ind == 1) return()
                                       cur_reference_level <<- svalue(cur_levels)
                                       ## adjust old
                                       relevel(old, cur_reference_level)
                                       ## adjust GUI
                                       blockHandler(cur_levels)
                                       tmp <- cur_levels[]
                                       tmp[c(1, ind)] <- tmp[c(ind, 1)]
                                       cur_levels[] <- tmp
                                       svalue(cur_levels, index=TRUE) <- 1
                                       unblockHandler(cur_levels)
                                     })
                                     tooltip(ref_button) <- "
For an unordered factor, the top most level is set
as the reference level.Clicking this button will
move the selected level to the top.
"
      
                                   }
                                   
                                   addSpring(cur_child)
                                   
                                   addHandler(rename_level, "key-press-event", handler=function(h, w, e, ...) {
                                     if(e$GetKeyval() != GDK_Return) {
                                       return(FALSE)
                                     }
                                     ind <- svalue(cur_levels, index=TRUE)
                                     new_name <- svalue(h$obj)
                                     ## adjust old
                                     tmp <- old
                                     levels(tmp)[ind] <- new_name
                                     old <<- tmp
                                     ## adjust GUI
                                     blockHandler(rename_level)
                                     tmp <- cur_levels[]
                                     tmp[ind] <- new_name
                                     cur_levels[] <- tmp
                                     svalue(cur_levels, index=TRUE) <- ind
                                     svalue(rename_level) <- ""
                                     unblockHandler(rename_level)
                                     focus(cur_levels) <- TRUE
                                     
                                     return(TRUE)
                                   })
                                 }
                                 
                                 more_than_one_selected <- function() {
                                   delete(rg, cur_child)
                                   cur_child <<- gvbox(container=rg, expand=TRUE)
                                   
                                   glabel("Collapse selected levels to:", container=cur_child, anchor=c(-1,0))
                                   collapse_levels <- gedit("", intial.msg="Collapse levels to...",
                                                            container=cur_child)
                                   addSpring(cur_child)
                                   
                                   addHandlerChanged(collapse_levels, handler=function(h,...) {

                                     ind <- svalue(cur_levels, index=TRUE)
                                     new_val <- svalue(collapse_levels)
                                     
                                     if (length(ind) < 2)
                                       return()
                                     ## adjust old
                                     tmp <- old
                                     levels(tmp)[ind] <- new_val
                                     old <<- tmp
                                     ## adjust GUI

                                     blockHandler(cur_levels);
                                     tmp <- cur_levels[]
                                     tmp[ind] <- new_val
                                     tmp <- tmp[-sort(ind)[-1]]
                                     cur_levels[] <- tmp
                                     unblockHandler(cur_levels)
                                     
                                     svalue(cur_levels, index=TRUE) <- sort(ind)[1]
                                   })
                                 }
                                 
                                 ##
                                 selection_changed <- function(...) {
                                   ind <- svalue(cur_levels, index=TRUE)
                                   if(length(ind) == 0)
                                     none_selected()
                                   else if(length(ind) == 1)
                                     one_selected()
                                   else
                                     more_than_one_selected()
                                 }
                                 
                                 
                                 addHandlerSelectionChanged(cur_levels, handler=function(h,...) {
                                   blockHandler(cur_levels)
                                   on.exit(unblockHandler(cur_levels))
                                   selection_changed()

                                 })
                                 addHandlerChanged(is_ordered, handler=function(h, ...) {
                                   ## adjust factor
                                   old <<- factor(old, ordered=svalue(h$obj))
                                   ## adjust GUI
                                   ind <- svalue(cur_levels, index=TRUE)
                                   if (length(ind)==0 || ind < 1)
                                     ind <- 1
                                   svalue(cur_levels, index=TRUE) <- ind
                                 })
                                 
                                 ##
                                 add_level_dialog <- function(parent) {
                                   ## add a level to current levels
                                   dlg <- gbasicdialog(parent=parent, handler=function(...) {
                                     new_val <- svalue(e)
                                     tmp <- cur_levels[]
                                     if(nchar(new_val) > 0 && !(new_val %in% tmp)) {
                                       ## adjust factor
                                       levels(old) <<- c(levels(old), new_val)
                                       ## add to GUI
                                       blockHandler(cur_levels)
                                       
                                       tmp <- c(tmp, new_val)
                                       cur_levels[] <- tmp
                                       
                                       unblockHandler(cur_levels)
                                       svalue(cur_levels, index=TRUE) <- length(tmp)
                                     }
                                   })
                                   g <- gvbox(cont=dlg)
                                   glabel("Add a new level to factor ...", cont=g, anchor=c(-1,0))
                                   e <- gedit("", container=g)
                                   visible(dlg, TRUE)
                                 }
                                 
                                 
                                 
                               },
                               get_value = function() {
                                 "Return factor with new levels"
                                 old
                               }
                               ))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtext.R"
##' @include GWidget.R
NULL


## Make a tag table to be shared. We use memoise as we only need to make this once.
make_tag_table <- memoise(gtkTextTagTableNew)

##' toolkit implementation
##'
##' @inheritParams gWidgets2::gtext
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gtext guiWidgetsToolkitRGtk2
##' @S3method .gtext guiWidgetsToolkitRGtk2
.gtext.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                    text = NULL, width = NULL, height = 300, font.attr = NULL,
                    wrap = TRUE,
                    handler = NULL, action = NULL, container = NULL,... ) {
  
  GText$new(toolkit,
            text = text, width = width, height = height,
            font.attr = font.attr, wrap = wrap,
            handler = handler, action = action, container = container, ...
            )

}


GText <- setRefClass("GText",
                     contains="GWidget",
                     fields=list(
                       buffer="ANY",
                       tag_table="ANY",
                       font_attr="list"
                       ),
                     methods=list(
                       initialize=function(toolkit=NULL,
                         text = NULL, width = NULL, height = 300,
                         font.attr = NULL, wrap = TRUE,
                         handler=NULL, action=NULL, container=NULL, ...) {

                         tag_table <<- make_tag_table()
                         buffer <<- gtkTextBufferNew(tag_table)
                         widget <<- gtkTextViewNewWithBuffer(buffer)
                         widget$SetLeftMargin(10)
                         widget$SetRightMargin(10)
                         if(wrap)
                           widget$SetWrapMode(GtkWrapMode['word'])
                         else
                           widget$SetWrapMode(GtkWrapMode['none'])

                         block <<- gtkScrolledWindowNew()
                         block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                         if(!is.null(width))
                           block$SetSizeRequest(width,height)
                         
                         block$add(widget)
                         widget$show()

                         font_attr <<- getWithDefault(font.attr, list())
                         insert_text(text, where="beginning",  do.newline=FALSE)
                         
                         add_to_parent(container, .self, ...)
                         
                         handler_id <<- add_handler_changed(handler, action)
                         
                         callSuper(toolkit)
                       },
                       get_value=function(drop=FALSE, ...) {
                         "Return text, or selected text if drop=TRUE"
                         if(is.null(drop) || drop == FALSE) {
                           start <- buffer$GetStartIter()$iter
                           end <- buffer$GetEndIter()$iter
                         } else {
                           ## return only **selected** text
                           ## if drop==TRUE
                           bounds <- buffer$GetSelectionBounds()
                           if(bounds$retval == FALSE)
                             return("") # no selectin
                           start <- bounds$start
                           end <- bounds$end
                         }
                         buffer$GetText(start, end) # has embedded "\n"
                       },
                       set_value=function(value, ...) {
                         "Replace all text, pasted together with newline"
                         args <- list(...)
                         drop <- getWithDefault(args$drop, FALSE)
                         bounds <- buffer$GetSelectionBounds()
                         if (drop && bounds$retval) {
                           ## replace selection with new string
                           buffer$insert(bounds$start, value, -1)
                           new_bounds <- buffer$GetSelectionBounds()
                           buffer$delete(new_bounds$start, new_bounds$end)
                         } else {
                           value <- paste(value, collapse="\n")
                           buffer$setText(value)
                         }
                       },
                       get_index = function(...) {
                         stop("Not defined")
                       },
                       set_index = function(value,...) {
                         stop("Not defined")
                       },
                       get_items = function(i, j, ..., drop=TRUE) {
                         stop("Not defined")
                       },
                       set_items = function(value, i, j, ...) {
                         stop("Not defined")
                       },
                       get_tag_name=function(name, value) {
                         "Return tag table name for passing to function"
                         value <- switch(name,
                                         "weight" = PangoWeight[value],
                                         "style"  = PangoStyle[value],
                                         "size"   = if(is.numeric(value)) {
                                           as.integer(value)
                                         } else {
                                           PangoScale[value] * 12
                                         },
                                         "scale"  = PangoScale[value],
                                         value)
                         name <- switch(name,
                                        "color"="foreground",
                                        "size" = "size-points",
                                        name)
                         nm <- sprintf("%s-%s", name, value)
                         if(is.null(tag_table$lookup(nm))) {
                           tt <- gtkTextTagNew(nm) # family-Monospace, say
                           tt[name] <- value
                           tag_table$add(tt)
                         }
                         nm
                       },
                       set_font = function(font.attr) {
                         "Set  font for selection or entire buffer if no selection"

                         font.attr <- sapply(font.attr, identity, simplify=FALSE)
                         if(length(font.attr) == 0)
                           return()

                         bounds <- buffer$GetSelectionBounds()
                         
                         if(bounds$retval == FALSE) {
                           ## if no text selected, we set for entire buffer
                           ## change entire buffer -- new as of 0.64
                           start <- buffer$GetStartIter()$iter
                           end <- buffer$GetEndIter()$iter
                           buffer$removeAllTags(start, end) # remove, the reset below
                         } else {
                           start <- bounds$start
                           end <- bounds$end
                         }

                         for(i in names(font.attr)) {
                           tag_nm <- get_tag_name(i, tolower(font.attr[i]))
                           buffer$ApplyTagByName(tag_nm, start, end)
                         }
                       },
                       insert_text=function(value, where, font.attr=NULL, do.newline,  ...) {
                         "Insert text into buffer. Font.attr is a list with named quantities" 
                         if(is_empty(value))
                           return()
                         
                          iter <- switch(where,
                                         "end"=buffer$GetEndIter()$iter,
                                         "beginning"=buffer$GetStartIter()$iter,
                                         buffer$getIterAtMark(buffer$getInsert())$iter)
            
                         value <- paste(c(value,""), collapse=ifelse(do.newline, "\n", ""))
                         arg_list <- list(object=buffer, iter=iter, text=value)

                         if(is.null(font.attr)) {
                           font.attr <- font_attr
                         } else {
                           font.attr <- sapply(font.attr, identity, simplify=FALSE)
                           font.attr <- gWidgets2:::merge.list(font_attr, font.attr)
                         }
                         if(length(font.attr) > 0) {
                           for(i in names(font.attr)) {
                             arg_list[[length(arg_list) + 1]] <- get_tag_name(i, font.attr[[i]])
                           }
                         }
                         do.call("gtkTextBufferInsertWithTagsByName",arg_list)                           

                         ## scroll to end -- if appended to end
                         if(where == "end") {
                           gdkWindowProcessAllUpdates()
                           while (gtkEventsPending())
                             gtkMainIterationDo(blocking=FALSE)
                           
                           end <- buffer$getEndIter()$iter
                           widget$scrollToIter(end, within.margin = 0, use.align=TRUE)
                         }
                         
                       },
                       add_handler_changed=function(handler, action=NULL, ...) {
                         add_handler_keystroke(handler, action=action, ...)
                       },
                       add_handler_selection_changed=function(handler, action=NULL, ...) {
                         message("No good signal for initiating this. Needs hacking XXX")
                       }
                       ))


  
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gimage.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gimage
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gimage guiWidgetsToolkitRGtk2
##' @S3method .gimage guiWidgetsToolkitRGtk2
.gimage.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                         filename = "", dirname = "", stock.id=NULL, size = "",
                                         handler = NULL,action = NULL, container = NULL, ... ) {
  GImage$new( toolkit,
             filename=filename, dirname=dirname, stock.id=stock.id, size=size,
             handler = handler,action = action, container = container, ...)
}


## Main class for gimage
GImage <- setRefClass("GImage",
                      contains="GWidget",
                      fields=list(
                        "image_name"="ANY", # name (filename or stock)
                        "stock_size"="integer"  # size if stock (GtkIconSize value)
                        ),
                      methods=list(
                        initialize=function(toolkit=NULL,
                          filename = "", dirname = "", stock.id=NULL, size = "",
                          handler=NULL, action=NULL, container=NULL, ...) {
                          

                          ## get file or stock
                          stock_size <<- 0L
                          if(!is.null(stock.id)) {
                            size <- switch(toupper(size),
                                           "MENU"= GtkIconSize["menu"],
                                           "SMALL_TOOLBAR"= GtkIconSize["small-toolbar"],
                                           "LARGE_TOOLBAR"= GtkIconSize["large-toolbar"],
                                           "BUTTON"= GtkIconSize["button"],
                                           "DND"= GtkIconSize["dnd"],
                                           "DIALOG"= GtkIconSize["dialog"],
                                           GtkIconSize["menu"])
                            image_name <<- getStockIconByName(stock.id, toolkit=toolkit)
                            stock_size <<- size
                          } else {
                            ## piece together name
                            if(nchar(dirname))
                              filename <- sprintf("%s%s%s", dirname, .Platform$file.sep, filename)
                            if(file.exists(filename)) {
                              image_name <<- filename
                            } else {
                              message(sprintf("File %s is not found", filename))
                              stop()
                            }
                          }

                          
                          widget <<- gtkImageNew()
                          block <<- gtkEventBoxNew()
                          block$setVisibleWindow(FALSE)
                          block$add(widget)

                          set_value(image_name)

                          add_to_parent(container, .self, ...)

                          initFields("change_signal"="button-press-event")
                          handler_id <<- add_handler_changed(handler, action)

                          callSuper(toolkit)
                        },
                        get_value=function( ...) {
                          image_name
                        },
                        set_value=function(value, ...) {
                          if(file.exists(value)) {
                            widget$setFromFile(value)
                          } else {
                            ## assume stock
                            value <- getStockIconByName(value, toolkit=toolkit)
                            widget$setFromStock(value, size=stock_size)
                          }
                          image_name <<- value
                        },
                        handler_widget=function() {
                          block
                        },
                        add_handler_changed=function(handler, action=NULL, ...) {
                          "Change handler is button-press-event"
                          add_handler_button_press(handler, action=action, ...)
                        },
                        add_handler_clicked=function(handler, action=NULL, ...) {
                          add_handler_changed(handler, action=action, ...)
                        }
                        ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/glabel.R"
##' @include GWidget.R
NULL

##' Toolkit label constructor
##'
##' @inheritParams gWidgets2::glabel
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .glabel guiWidgetsToolkitRGtk2
##' @S3method .glabel guiWidgetsToolkitRGtk2
.glabel.guiWidgetsToolkitRGtk2 <- function(toolkit, text="", markup=FALSE, editable=FALSE,
                                           handler=NULL, action=NULL, container=NULL,
                                           ...) {
  GLabel$new(toolkit, text, markup, editable, handler, action, container, ...)
}

##' label class for RGtk2
##'
##' The label class for RGtk2 has the extra method
##' \code{set_angle} to set the angle for the
##' text. A value of 90 will rotate ccw to read bottom to top
##' @rdname gWidgets2RGtk2-package
GLabel <- setRefClass("GLabel",
                            contains="GWidget",
                            fields=list(
                              markup="ANY",
                              editable="logical",
                              edit_widget = "ANY",
                              state="character"
                              ),
                            methods=list(

                              
                              initialize=function(toolkit=NULL, text, markup=FALSE, editable=FALSE, handler, action, container, ...) {

                                widget <<- gtkLabel()
                                widget$setSelectable(TRUE)
                                if(markup)
                                  widget$setUseMarkup(TRUE)

                                ## we put in an event box to catch events for the handler and editable stuff.
                                ## Likely that should just be done away with, but here it is.
                                block <<- gtkEventBoxNew()
                                gp <- gtkHBox()
                                block$add(gp)
                                gp$packStart(widget)

                                initFields(
                                           markup=markup,
                                           editable=editable,
                                           change_signal="button-press-event"
                                           )
                                add_to_parent(container, .self, ...)

                                set_value(text)
                                if(editable) {
                                  ## don't confuse mouse users
                                  widget$setSelectable(FALSE)
                                  
                                  ## capture events at block
                                  block$setAboveChild(TRUE)
                                  block$setVisibleWindow(FALSE)
                                  
                                  ## Set up widget to toggle between
                                  state <<- "label"
                                  edit_widget <<- gtkEntryNew()
                                  edit_widget$hide()
                                  gp$packStart(edit_widget)
                                  gSignalConnect(edit_widget, "activate", function(e) {
                                    show_label_widget()
                                  })

                                  handler <- function(...) {
                                    if(state == "label") show_edit_widget() else show_label_widget()
                                    FALSE
                                  }
                                  handler_id <<- gSignalConnect(block, "button-press-event", handler)
                                  
                                }
                                
                                callSuper(toolkit)
                              },

                              
                              ## set the value
                              set_value=function(value, index=TRUE, drop=TRUE, ...) {
                                value <- paste(value, collapse="\n")
                                if(markup)
                                  widget$setMarkup(value)
                                else
                                  widget$setLabel(value)
                                ## signal change, not done by widget
                                invoke_change_handler()
                              },
                              ## tricky part is for markup
                              get_value=function(index=TRUE, drop=TRUE, ...) {
                                value <- widget$getLabel()
                                 if(markup)
                                   value <- gsub("<[^>]*>","",value)
                                value
                              },

                              ## methods for editing
                              show_edit_widget = function() {
                                edit_widget$grabFocus()
                                edit_widget$setText(get_value())
                                widget$hide()
                                edit_widget$show()
                                state <<- "edit"
                              },
                              show_label_widget = function() {
                                set_value(edit_widget$getText())
                                edit_widget$hide()
                                widget$show()
                                state <<- "label"
                                
                              },
                              ## Handler
                              handler_widget = function() block, # put on block,not widget
                              add_handler_changed=function(handler, action=NULL, ...) {
                                add_handler_clicked(handler, action=action, ...)
                              },
                              add_handler_clicked=function(handler, action=NULL, ...) {

                                block$addEvents(GdkEventMask["all-events-mask"])
                                
                                add_handler(block, "button-press-event", event_decorator(handler), action)
                              },


                              ## secret methods
                              set_angle = function(angle) {
                                "Rotate text by angle degrees ccw"
                                widget$setAngle(as.integer(angle)[1])
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtimer.R"
##' @include GWidget.R
NULL

##' S3 method for gtimer
##'
##' @inheritParams gWidgets2::gtimer
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gtimer guiWidgetsToolkitRGtk2
##' @S3method .gtimer guiWidgetsToolkitRGtk2
.gtimer.guiWidgetsToolkitRGtk2 <- function(toolkit, ms, FUN, data=NULL, one.shot=FALSE, start=TRUE)
  GTimer$new(toolkit, ms, FUN, data=data, one.shot=one.shot, start=start)

##' Timer class for gWidgets.
##'
##' The main reference methods \code{GTimer} are \code{start_timer} and \code{stop_timer}
##' @rdname gWidgets2RGtk2-package
GTimer <- setRefClass("GTimer",
                      fields=list(
                        "oneShot"="logical",
                        "started" = "logical",
                        interval="integer",
                        data="ANY",
                        FUN="ANY",
                        FUN_wrapper="ANY",
                        ID = "ANY"
                        ),
                      methods=list(
                        initialize=function(toolkit=guiToolkit(), ms, FUN=function(...) {},
                          data=NULL,
                          one.shot=FALSE, start=TRUE) {
                          
                          f <- function(data) {
                            FUN(data)
                            if(one.shot) {
                              stop_timer()
                              FALSE
                            } else {
                              TRUE
                            }
                          }

                          initFields(started=FALSE,
                                     interval=as.integer(ms),
                                     oneShot=one.shot,
                                     data=data,
                                     FUN=FUN,
                                     FUN_wrapper=f
                                     )
                          
                          if(start) 
                            start_timer()
                          
                          callSuper()
                        },
                        ## Main interface for gtimer:
                        set_interval=function(ms) {
                          "Set the interval. Need to stop and start active timer to implement."
                          interval <<- as.integer(ms)
                        },
                        start_timer = function() {
                          "Start the timer"
                          if(!started) {
                            ID <<- gTimeoutAdd(interval, FUN_wrapper, data = data)
                          }
                          started <<- TRUE
                        },
                        stop_timer = function() {
                          "stop the timer"
                          gSourceRemove(ID)
                          started <<- FALSE
                        }))
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gtree.R"
##' @include GWidget.R
NULL

## need to finish update_widget
## another handler?

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gtree
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gtree guiWidgetsToolkitRGtk2
##' @S3method .gtree guiWidgetsToolkitRGtk2
.gtree.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                           offspring = NULL, offspring.data = NULL,
                                           chosen.col = 1, offspring.col=2, icon.col=NULL, tooltip.col=NULL,
                                           multiple = FALSE,
                                           handler = NULL,action = NULL, container = NULL, ... ) {
  GTree$new(toolkit,
            offspring=offspring, offspring.data=offspring.data,
            chosen.col=chosen.col, offspring.col=offspring.col, icon.col=icon.col, tooltip.col=tooltip.col,
            multiple=multiple,
            handler = handler,action = action, container = container, ...)
}


##' Base class
##'
##' For \code{GTree}, there are extra reference methods:
##' \code{set_multiple} to set whether multiple or single selection is
##' being used.
##' @param ... passed to constructor
GTreeBase <- setRefClass("GTreeBase",
                         contains="GWidget",
                         fields=list(
                           multiple="logical"
                           ),
                         methods=list(
                           set_selection_mode=function(mode=c("none", "single", "browse", "multiple", "extended")) {
                             "Helper: Set the selection mode"
                             sel_model <- widget$getSelection()
                             sel_model$setMode(GtkSelectionMode[match.arg(mode)])
                           },
                           set_multiple=function(value) {
                             if(value) {
                           set_selection_mode("multiple")
                           multiple <<- TRUE
                         } else {
                           set_selection_mode("single")
                           multiple <<- FALSE
                         }
                           },
                       walk_back_from_path=function(path) {
                         "Walk the tree back from path"
                         ## assume path is not from sorted store
                         if(is.numeric(path)) {
                           ## create GtkTreePath
                           tpath <- paste(path - 1L, collapse=":")
                           path <- gtkTreePathNewFromString(tpath)
                         }
                         stopifnot(is(path, "GtkTreePath"))
                         
                         model <- widget$getModel()$getModel()
                         iter <- model$getIter(path)
                         walk_back_from_iter(iter)
                       },
                       walk_back_from_iter=function(iter) {
                         "Walk the tree back from iter"
                         model <- widget$getModel()$getModel()
                         vals <- c()
                         while(iter$retval) {
                           vals <- c(model$getValue(iter$iter, chosen_col -1L)$value, vals)
                           iter <- model$iterParent(iter$iter)
                         }
                         vals
                       },
                           add_label=function(view_col) {
                             "Add label widget to hold names. This allows us to intercept clicks if desired"
                             event_box <- gtkEventBox()
                             event_box$SetVisibleWindow(FALSE)
                             label <- gtkLabel()
                             ##event_box$addEvents('all-events-mask')
                             event_box$add(label)
                             event_box$setAboveChild(TRUE)         # gets events to box
                             view_col$setWidget(event_box)
                           },

                           make_key_column=function() {
                             "Make column for keys"
                             view_col <- gtkTreeViewColumnNew()
                             view_col$setResizable(TRUE)
                             cellrenderer <- gtkCellRendererText()
                             view_col$PackStart(cellrenderer, TRUE)
                             cellrenderer['xalign'] = 0
                             ##
                             add_label(view_col)
                             view_col
                           },

                           make_columns=function(items) {
                             "Make new columns"
                             
                             widget$insertColumn(make_key_column(), pos=1L) # first column
                             
                             ## now add columns,
                             f <- function(x, i) {
                               treeview_col <- make_treeview_column(x, i - 1, .self)
                               widget$insertColumn(treeview_col, pos = -1) # at end
                             }
                             mapply(f, items, seq_len(ncol(items)))
                           },                           
                           get_view_columns=function() {
                             "Helper: get  columns to iterate over"
                             columns <- widget$getColumns()
                             columns
                           }, 
                           
                       ## main methods
                       get_value=function(i, drop=TRUE,...) {
                         "Return path (by chosen col)"
                         sel_model <- widget$getSelection()
                         selected_rows <- sel_model$getSelectedRows()
                         sel_list <- selected_rows$retval # a list of GtkTreePath objects
                         if(length(sel_list) == 0)
                           return(character(0)) # no selection

                         sorted_model <- widget$getModel()
                         model <- sorted_model$getModel() # non-sorted
                         
                         out <- lapply(sel_list, function(i) {
                           us_path <- sorted_model$ConvertPathToChildPath(i)
                           walk_back_from_path(us_path)
                         })
                         if(!is.null(drop) && drop)
                           out <- lapply(out, tail, n=1)
                         if(length(out) == 1)
                           out <- out[[1]]
                         out
                       },
                       set_value=function(value, ...) {
                         "open path, set via match"
                         ## this is trickier than it look
                         
                       },
                       get_index = function(...) {
                         "get path index as integer vector"
                         sel_model <- widget$getSelection()
                         selected_rows <- sel_model$getSelectedRows()
                         sel_list <- selected_rows$retval # a list of GtkTreePath objects
                         if(length(sel_list) == 0)
                           return(integer(0)) # no selection

                         sorted_model <- widget$getModel()
                         model <- sorted_model$getModel() # non-sorted

                         
                         out <- lapply(sel_list, function(i) {
                           us_path <- sorted_model$ConvertPathToChildPath(i)
                           as.numeric(strsplit(us_path$toString(), ":")[[1]]) + 1L
                         })
                         if(length(out) == 1)
                           out <- out[[1]]
                         out
                       },
                       set_index = function(value,...) {
                         "open to specifed index, if possible"
                         ## value may be a list
                         if(!is.list(value))
                           value <- list(value)

                         clear_selection() # out with old, in with new
                         sel <- widget$getSelection()
                         sapply(value, function(path) {
                           path <- paste(path-1L, collapse=":")
                           widget$expandToPath(gtkTreePathNewFromString(path))
                           widget$collapseRow(gtkTreePathNewFromString(path))
                           sel$selectPath(gtkTreePathNewFromString(path))
                         })
                       },
                       get_items = function(i, j, ..., drop=TRUE) {
                         "Get items in the selected row"
                         sel_model <- widget$getSelection()
                         selected_rows <- sel_model$getSelectedRows()
                         sel_list <- selected_rows$retval # a list of GtkTreePath objects
                         if(length(sel_list) == 0)
                           return(character(0)) # no selection

                         sorted_model <- widget$getModel()
                         model <- sorted_model$getModel() # non-sorted

                         n <- model$getNColumns()
                         out <- lapply(sel_list, function(i) {
                           us_path <- sorted_model$ConvertPathToChildPath(i)
                           iter <- model$getIter(us_path)
                           not_these <- unlist(list(icon_col, tooltip_col, offspring_col))
                           these <- setdiff(seq_len(n), not_these)
                           lapply(these, function(i) model$getValue(iter$iter, i - 1L)$value)
                         })
                         if(getWithDefault(drop, FALSE)) {
                           out <- lapply(out, function(x) x[[chosen_col]])
                         }
                         out <- do.call(rbind, out)
                         colnames(out) <- get_names()
                         out
                       },
                       set_items = function(value, i, j, ...) {
                         stop(gettext("One sets items at construction through the x argument of offspring function"))
                       },
                       get_names=function() {
                         sapply(.self$get_view_columns, function(col) col$getWidget()$getChild()$getLabel())
                       },
                       set_names=function(value) {
                         f <- function(col, nm) {
                           label <- col$getWidget()$getChild()
                           label$setLabel(nm)
                         }
                         mapply(f, .self$get_view_columns(), value)
                       },
                       ##
                       add_handler_changed=function(handler, action=NULL, ...) {
                         add_handler("row-activated", handler, action=action, ...)
                       },
                             add_handler_clicked=function(handler, action=NULL, ...) {
                                 add_handler_button_release(handler, action=action, ...)
                             },
                       ## Some extra methods
                       clear_selection=function() {
                         widget$getSelection()$unselectAll()

                       }
                       ))



##' Base class
##'
##' For \code{GTree}, there are extra reference methods:
##' \code{set_multiple} to set whether multiple or single selection is
##' being used.
##' @param ... passed to constructor
GTree <- setRefClass("GTree",
                     contains="GTreeBase",
                     fields=list(
                       chosen_col="IntegerOrNULL",
                       offspring_col="IntegerOrNULL",
                       icon_col="IntegerOrNULL",
                       tooltip_col="IntegerOrNULL",
                       offspring_data="ANY"
                       ),
                     methods=list(
                       initialize=function(toolkit=NULL,
                         offspring = NULL, offspring.data = NULL,
                         chosen.col = 1, offspring.col=2, icon.col=NULL, tooltip.col=NULL,
                         multiple = FALSE,
                         handler=NULL, action=NULL, container=NULL, ...) {

                         widget <<- gtkTreeViewNew()
                         block <<- gtkScrolledWindowNew()
                         block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                         block$add(widget)

                         set_multiple(multiple)

                         
                         ## call offspring to get data frame
                         items <- offspring(c(), offspring.data)

                         ## we want column index, not name
                         .character_to_index <- function(val, x) {
                           if(is.character(val)) {
                             if(is.element(val, x))
                               val <- match(val, x)
                             else
                               val <- NULL
                           }
                           if(is.numeric(val))
                             val <- as.integer(val)
                           val
                         }
                         icon.col <- .character_to_index(icon.col, names(items))
                         tooltip.col <- .character_to_index(tooltip.col, names(items))
                         offspring.col <- .character_to_index(offspring.col, names(items))
                         chosen.col <- .character_to_index(chosen.col, names(items))

                         initFields(chosen_col=chosen.col,
                                    offspring_col=offspring.col,
                                    icon_col = icon.col,
                                    tooltip_col=tooltip.col,
                                    offspring_data=offspring.data,
                                    change_signal="row-activated",
                                    default_expand=TRUE,
                                    default_fill=TRUE,
                                    toolkit=toolkit # needed here for gmenu call later
                                    )

                      
                         ## we add columns for each column in items, but don't display all of them
                         types <- sapply(items, RtoGObjectConversion)
                         model <- gtkTreeStoreNew(types)
                         model <- gtkTreeModelSortNewWithModel(model)
                         widget$setModel(model)

                         make_columns(items)

                         add_child_items(items, NULL)
                         set_names(names(items)[-unlist(list(offspring_col, icon_col, tooltip_col))])

                         ## Main configuration respond to open event, close event by populating 
                         gSignalConnect(widget, "row-expanded", function(view, iter, path, ...) {
                           sorted_model <- widget$getModel()
                           model <- sorted_model$getModel()                           

                           us_path <- sorted_model$convertPathToChildPath(path)
                           iter <- model$getIter(us_path)

                           path <- walk_back_from_iter(iter)
                           children <- offspring(path, offspring.data)
                           add_child_items(children, iter$iter)
                           ## remove errant offspring
                           child_iter <- model$IterChildren(iter$iter)
                           if(child_iter$retval)
                             model$remove(child_iter$iter)
                         })

                         gSignalConnect(widget, "row-collapsed", function(view, iter, path, ...) {
                           ## get unsorted iter from path
                           sorted_model <- widget$getModel()
                           model <- sorted_model$getModel() # non-sorted

                           uspath <- sorted_model$ConvertPathToChildPath(path)
                           iter <- model$GetIter(uspath)$iter
                           ## get children, remove
                           n <- model$IterNChildren(iter)
                           if(n > 1) { ## n=1 gets removed when expanded
                             for(i in 1:(n-1)) {
                               child_iter <- model$IterChildren(iter)
                               if(child_iter$retval)
                                 model$Remove(child_iter$iter)
                             }
                           }

                         })
                         
                         
                         add_to_parent(container, .self, ...)
                         
                         handler_id <<- add_handler_changed(handler, action)
                         
                         callSuper(toolkit)
                       },
                       make_columns=function(items) {
                         "Make new columns, watching outE for icons, tooltips, visible"
                         
                         widget$insertColumn(make_key_column(), pos=1L) # first column
                         
                         if(!is.null(tooltip_col)) {
                           ## use column tooltip_col - 1L for a tooltip
                           x <- seq_along(items);
                           if(!is.null(tooltip_col)) {
                             widget$setTooltipColumn(tooltip_col - 1L)
                           }
                         }

                         
                         ## now add columns, one by one skipping ones we don't represent
                         not_these <- unlist(list(chosen_col, icon_col, tooltip_col, offspring_col))
                         these <- setdiff(seq_along(items), not_these)
                         sapply(these, function(col) {
                           treeview_col <- make_treeview_column(items[,col], col - 1L, .self)
                           widget$insertColumn(treeview_col, pos = -1) # at end
                          })
                        },
                       make_key_column=function() {
                         "Make column for key and icons, if present"
                         view_col <- gtkTreeViewColumnNew()
                         view_col$setResizable(TRUE)
                         if(!is.null(icon_col)) {
                            cellrenderer <- gtkCellRendererPixbufNew()
                            view_col$PackStart(cellrenderer, FALSE)
                            view_col$AddAttribute(cellrenderer, "stock-id", icon_col - 1L)
                          }
                         cellrenderer <- gtkCellRendererText()
                         view_col$PackStart(cellrenderer, TRUE)
                         cellrenderer['xalign'] = 0
                         view_col$AddAttribute(cellrenderer, "text", chosen_col - 1L)
                         ##
                         add_label(view_col)
                         view_col
                       },
                       get_view_columns=function() {
                         "Helper: get non-icon columns to iterate over"
                         columns <- widget$getColumns()
                         if(!is.null(icon_col))
                           columns <- columns[-1]
                         columns
                       }, 

                       ## tree methods
                       add_child_items=function(children, parent.iter=NULL) {
                         model <- widget$getModel()$getModel()
                         if(nrow(children) == 0)
                           return()

                         has_offspring <- children[,offspring_col]
                         
                         ## load row by row, column by column
                         ## we add columns for offspring, ... as these are needed to count
                         for(i in 1:nrow(children)) {
                           iter <- model$Append(parent=parent.iter)
                           ## now write values for each column
                           for(j in 1:ncol(children)) {
                             model$SetValue(iter$iter, column=j-1, children[i,j])
                           }
                           ## add branch?

                           if(has_offspring[i]) {
                             model$Append(parent=iter$iter)
                           }
                         }
                         
                       },
                       update_widget=function(...) {
                         "Update base of widget, reopen selected paths if possible"
                         block_observers()
                         cur_sel <- get_index()
                         widget$collapseAll()

                         ## clear base
                         model <- widget$getModel()$getModel()
                         n <- model$IterNChildren(NULL)
                         if(n >= 1) {
                           for(i in 0:(n-1)) {
                             child_iter <- model$IterChildren(NULL)
                             if(child_iter$retval)
                               model$Remove(child_iter$iter)
                           }
                         }
                         ## repopulate
                         items <- offspring(c(), offspring_data)
                         add_child_items(items, NULL)
                         set_index(cur_sel)
                         unblock_observers()                         
                       }
                       ))




## Class to explore data frame
GTreeDataFrame <- setRefClass("GTreeDataFrame",
                              contains="GTreeBase",
                              fields=list(
                                idx="numeric"
                                ),
                              methods=list(
                                initialize=function(DF, INDICES,
                                  multiple = FALSE,
                                  handler=NULL, action=NULL, container=NULL, ...) {
                                  
                                  ## check that INDICES are numeric or in names
                                  if(missing(INDICES))
                                    stop(gettext("INDICES are required. May be of length 1 or more"))
                                  if(is.numeric(INDICES)) {
                                    INDICES <- as.integer(INDICES)
                                  } else if(is.character(INDICES)) {
                                    if(!all(INDICES %in% names(DF)))
                                      stop(gettext("INDICES are numeric index or subset of names"))
                                    INDICES <- match(INDICES, names(DF))
                                  } else {
                                    stop(gettext("INDICES are numeric index or subset of names"))
                                  }
                                  idx <<- as.integer(INDICES)
                                  
                                  ## make tree widget
                                  ## create view and style
                                  
                                  widget <<- gtkTreeViewNew()
                                  block <<- gtkScrolledWindowNew()
                                  block$SetPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                                  block$add(widget)
                                  
                                  set_multiple(multiple)

                                  initFields(
                                             change_signal="row-activated")

                                  items <- DF[-idx]
                                  types <- sapply(items, RtoGObjectConversion)
                                  model <- gtkTreeStoreNew(types)
                                  model <- gtkTreeModelSortNewWithModel(model)
                                  widget$setModel(model)

                                  make_columns(items)
                                  set_names(c("key", names(items)))
                                  
                                  populate_tree(DF, idx)

                                  
                                  add_to_parent(container, .self, ...)
                         
                                  handler_id <<- add_handler_changed(handler, action)
                         
                                  callSuper(toolkit)
                                },
                                populate_tree=function(DF, ind) {
                                  l <- split(DF, DF[[ind[1]]])
                                  mapply(.self$populate_level, names(l), l, list(ind[-1]), list(root_node()))
                                },
                                root_node=function() {
                                  "Return root node"
                                  NULL
                                },
                                populate_level=function(nm, DF, ind, node) {
                                  ## what to do. If ind has values, we recurse
                                  model <- widget$getModel()$getModel()
                                  if(length(ind) > 0) {
                                    iter <- model$append(parent=node)$iter
                                    model$setValue(iter, column=0, nm)

                                    lst <- split(DF, factor(DF[[ ind[1] ]]))
                                    mapply(.self$populate_level, names(lst), lst, list(ind[-1]), list(item))
                                  } else {
                                    sapply(seq_len(nrow(DF)), function(i) {
                                      iter <- model$Append(parent=node)$iter
                                      values <- sapply(DF[i,-idx, drop=FALSE], as.character)
                                      for(j in seq_along(values))
                                        model$setValue(iter, column=j, values[j])
                                    })
                                  } 
                                }
                                ))
                                  
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gvarbrowser.R"
##' @include GWidget.R
NULL

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gvarbrowser
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gvarbrowser guiWidgetsToolkitRGtk2
##' @S3method .gvarbrowser guiWidgetsToolkitRGtk2
.gvarbrowser.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                                 handler = NULL,action = "summary", container = NULL, ... ) {
  GVarBrowser$new(toolkit,
                  handler = handler,action = action, container = container, ...)
}


## Class for variable browser.
GVarBrowser <- setRefClass("GVarBrowser",
                            contains="GWidget",
                          fields=list(
                            "model"="ANY",
                            "ws_model"="ANY",
                            "filter_classes"="list",
                            "filter_name"="character",
                            "other_label"="character",
                            "timer"= "ANY",
                            "use_timer"="logical"
                             ),
                            methods=list(
                              initialize=function(toolkit=NULL,
                                handler=NULL, action=NULL, container=NULL, ...) {

                                ws_model <<- gWidgets2:::WSWatcherModel$new()
                                o = gWidgets2:::Observer$new(function(self) {self$update_view()}, obj=.self)
                                ws_model$add_observer(o)

                                
                                model <<- gtkTreeStore(c(key="gchararray", summary="gchararray",
                                                        icon="gchararray", background="gchararray",
                                                        digest="gchararray"))

                                widget <<-  gtkTreeViewNew()
                                widget$setModel(model)
                                widget$setRulesHint(TRUE) # shading
                                widget$getSelection()$setMode(GtkSelectionMode["multiple"])
                                
                                block <<- gtkScrolledWindowNew()
                                block$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
                                block$add(widget)

                                initFields(
                                           filter_classes=gWidgets2:::gvarbrowser_default_classes,
                                           filter_name="",
                                           other_label="Others",
                                           use_timer=TRUE
                                           )
                                
                                add_view_columns()
                                init_model()
                                add_context_menu()
                                ## drop target. Returns object of class ???
                                add_drop_source(handler=function(h,...) {
                                  l <- list(name=svalue(h$obj),
                                            obj=svalue(h$obj, drop=FALSE)
                                            )
                                  class(l) <- c("gvarbrowser_dropdata", class(l))
                                  l
                                }, action=NULL, data.type="object")

                                
                                add_to_parent(container, .self, ...)

                                handler_id <<- add_handler_changed(handler, action)


                                ## Try our oown timer. Need to check in update view the size and slow down if too large
                                timer <<- gtimer(1000, function(...) .self$ws_model$update_state())
                                
                                update_view()

                                
                                callSuper(toolkit)
                              },
                              start_timer=function() if(use_timer) timer$start_timer(),
                              stop_timer=function() timer$stop_timer(),
                              adjust_timer=function(ms) {
                                "Adjust interval to size of workspace"
                                if(missing(ms)) {
                                  n <- length(ls(envir=.GlobalEnv))
                                  ms <- 1000 * floor(log(5 + n, 5))
                                }
                                timer$set_interval(ms)
                              },
                              set_filter_name=function(value) {
                                filter_name <<- value
                                update_view()
                              },
                              set_filter_classes=function(value) {
                                filter_classes <<- value
                                update_view()
                              },
                              
                              
                              add_view_columns=function() {
                                "Add view columns"
                                view.col <- gtkTreeViewColumnNew()

                                cellrenderer <- gtkCellRendererPixbufNew()
                                view.col$PackStart(cellrenderer, FALSE)
                                view.col$AddAttribute(cellrenderer, "stock-id", 2L)

                                cellrenderer <- gtkCellRendererText()
                                view.col$PackStart(cellrenderer, TRUE)
                                view.col$AddAttribute(cellrenderer, "text", 0L)
                                view.col$AddAttribute(cellrenderer, "font", 3L)

                                view.col$setTitle(gettext("Object"))
                                widget$insertColumn(view.col, pos=-1)
                                
                                
                                ##  now summary
                                view.col <- gtkTreeViewColumnNew()
                                cellrenderer <- gtkCellRendererText()
                                view.col$PackStart(cellrenderer, TRUE)
                                view.col$AddAttribute(cellrenderer, "text", 1L)
                                view.col$setTitle(gettext("Description"))
                                
                                widget$insertColumn(view.col, pos=-1)
                              },
                              init_model=function() {
                                "Put in headings Data, Data sets, ..."
                                for(i in c(names(filter_classes), gettext(other_label))) {
                                  parent_iter <- model$append(NULL)      # toplevel item
                                  model$setValue(parent_iter$iter, column=0, value=i)
                                  model$setValue(parent_iter$iter, column=3L, value="bold")
                                }
                              },
                              add_value=function(x, name, iter) {
                                "Add a row to the model"
                                model$setValue(iter$iter, column=0, name)
                                model$setValue(iter$iter, column=1, short_summary(x))
#                                model$setValue(iter$iter, column=2, icon_for_object(x))
                                model$setValue(iter$iter, column=2, stockIconFromObject(toolkit, x))
                                model$setValue(iter$iter, column=3L, value="")
                                model$setValue(iter$iter, column=4L, value=digest(x))
                                ## recurse if needed
                                if(is.list(x) && !is.null(attr(x, "names"))) {
                                  lapply(names(x), function(i) {
                                    child_iter <- model$append(iter$iter)
                                    add_value(x[[i]], i, child_iter)
                                  })
                                }
                              },
                              update_view=function(...) {
                                "Ugly function to update browser"
                                stop_timer()
                                adjust_timer()
                                ## helper function
                                modify_children <- function(out_names, out, parent_iter) {
                                  child_iter <- model$iterChildren(parent_iter$iter)
                                  if(flag <- child_iter$retval) {
                                    ## we have children, so we loop over current ones and check
                                    while(flag) {
                                      key <- model$getValue(child_iter$iter, column=0)$value
                                      remove_key <- replace_key <- FALSE
                                      if(!is.null(key)) {
                                        if(key %in% out_names) {
                                          ## "Alread there did it change?"
                                          dgest <- model$getValue(child_iter$iter, column=4L)$value
##                                          print(list("modify children", dgest, digest(get(key, .GlobalEnv))))
                                          if(dgest != digest(get(key, .GlobalEnv))) {
                                            replace_key <- TRUE
                                          } else {
                                          }
                                          out_names <- setdiff(out_names, key)
                                        } else {
                                          remove_key <- TRUE          # remove later
                                        }
                                        ## now insert those between
                                        ind <- out_names < key
                                        if(length(ind) && any(ind)) {
                                          add_nms <- out_names[ind]
                                          out_names <- out_names[out_names > key]
                                          for(j in rev(add_nms)) {
                                            iter <- model$insertBefore(parent=parent_iter$iter, sibling=child_iter$iter)
                                            add_value(out[[j]], name=j,  iter=iter)
                                          }
                                        }
                                        if(replace_key) {
                                          ## add in one, then remove
                                          iter <- model$insertBefore(parent=parent_iter$iter, sibling=child_iter$iter)
                                          add_value(out[[key]], name=key, iter=iter)
                                          remove_key <- TRUE
                                        }
                                        if(remove_key) {
                                          ## not there now, we remove
                                          flag <- model$remove(child_iter$iter)
                                        } else {
                                          flag <- model$iterNext(child_iter$iter)
                                        }        
                                      }
                                    }
                                  }
                                  ## now append what is left
                                  if(length(out_names)) {
                                    for(j in out_names) {
                                      child_iter <- model$append(parent=parent_iter$iter)
                                      add_value(out[[j]], name=j,  iter=child_iter)      
                                    }
                                  }
                                }
                                
                                ## Now loop over filter_classes and modify each child
                                for(i in names(filter_classes)) {
                                  
                                  ## Compute names of objects at this level. (From wsmodel)
                                  klasses <- filter_classes[[i]]
                                  out <- ws_model$get_by_function(function(y)  length(Filter(function(x) is(y, x), klasses) > 0))
                                  out_names <- names(out)
                                  idx <- order(out_names)
                                  parent_iter <- model$getIterFromString(as.character(match(i, names(filter_classes)) - 1L))
                                  modify_children(out_names[idx], out[idx], parent_iter)
                                }
                                ## now do others
                                klasses <- unlist(filter_classes)
                                out <- ws_model$get_by_function(function(y)  !(length(Filter(function(x) is(y, x), klasses) > 0)))
                                out_names <- names(out)
                                idx <- order(out_names)
                                parent_iter <- model$getIterFromString(as.character(length(filter_classes)))
                                modify_children(out_names[idx], out[idx], parent_iter)
                                ##
                                start_timer()
                              },
                              ## These are from gtree. How to share?
                              walk_back_from_path=function(path) {
                                "Walk the tree back from path"
                                if(is.numeric(path)) {
                                  ## create GtkTreePath
                                  tpath <- paste(path - 1L, collapse=":")
                                  path <- gtkTreePathNewFromString(tpath)
                                }
                                stopifnot(is(path, "GtkTreePath"))
                                
                                iter <- model$getIter(path)
                                walk_back_from_iter(iter)
                              },
                              walk_back_from_iter=function(iter) {
                                "Walk the tree back from iter"
                                vals <- c()
                                while(iter$retval) {
                                  vals <- c(model$getValue(iter$iter,0L)$value, vals)
                                  iter <- model$iterParent(iter$iter)
                                }
                                vals[-1] # drop first
                              },
                              
                              get_value=function(drop=TRUE, ...) {
                                "Get selected values as names. A value may be 'name' or 'lst$name1$name2'"
                                out <- get_items(drop=FALSE)
                                drop <- getWithDefault(drop, TRUE) # may be NULL
                                if(is.null(drop) || drop) {
                                  out <- lapply(out, function(x) {
                                    sapply(x, function(i) ifelse(grepl("\\s", i),
                                                                 sprintf("'%s'", i),
                                                                 i))
                                  })
                                  out <- lapply(out, function(i) paste(i, collapse="$"))
                                  if(length(out) == 1)
                                    out <- out[[1]]
                                } else {
                                  ## return objects, not values
                                  out <- lapply(out, gWidgets2:::get_object_from_string)
                                }
                                out
                              },
                              set_value=function(value, ...) {
                                "Select and open value given."
                              },
                              get_index = function(...) {
                                "Get index of selected value: path, drop first, shift"
                                sel_model <- widget$getSelection()
                                selected_rows <- sel_model$getSelectedRows()
                                sel_list <- selected_rows$retval # a list of GtkTreePath objects
                                if(length(sel_list) == 0)
                                  return(numeric(0)) # no selection
                                ## we need to drop first and add one
                                out <- lapply(sel_list, function(path) {
                                  tmp <- path$toString()
                                  tmp <- as.numeric(strsplit(tmp, ":")[[1]])
                                  tmp <- tmp[-1] # drop first
                                  tmp + 1
                                })
                                if(length(out) == 1) out <- out[[1]]
                                out
                              },
                              get_items = function(i, j, ..., drop=TRUE) {
                                "Return value without $, but as vector. Not sure, why"
                                sel_model <- widget$getSelection()
                                selected_rows <- sel_model$getSelectedRows()
                                sel_list <- selected_rows$retval # a list of GtkTreePath objects
                                if(length(sel_list) == 0)
                                  return(character(0)) # no selection
                                
                                out <- lapply(sel_list, .self$walk_back_from_path)
                                if(drop && length(out) == 1)
                                  out <- out[[1]]
                                out
                              },
                              set_items = function(value, i, j, ...) {
                                
                              },
                              add_handler_changed=function(handler, action=NULL, ...) {
                                add_handler("row-activated", handler, action=action, ...)
                              },
                              add_handler_selection_changed=function(handler, action=NULL, ...) {
                                ## not perfect
                                add_handler("select-cursor-row", handler, action=action, ...)
                              },
                              ## context menu popup
                              add_context_menu=function() {
                                ## call back
                                on_button_pressed <- function(view, event, data) {
                                  if(gWidgets2RGtk2:::isRightMouseClick(event)) {
                                    ret <- view$getPathAtPos(event$x, event$y)
                                    if(!ret$retval)
                                      return(FALSE)
                                    
                                    path <- ret$path
                                    out <- walk_back_from_path(path)
                                    if(length(out) == 0)
                                      return(FALSE)

                                    nm <- paste(out, collapse="$")
                                    obj <- gWidgets2:::get_object_from_string(out)
                                    ## popup menu
                                    menu <- gtkMenuNew()
                                    menu$append(gtkMenuItemNewWithLabel(gettext(sprintf("Actions for %s:", nm))))
                                    menu$append(gtkSeparatorMenuItem())


                                    popup_actions(obj, nm, menu)
                                    
                                    ## ## XXX Need to make this item sensistive. S3 method to dispatch on out
                                    ## ## rm, only if length 1
                                    ## if(length(out) == 1) {
                                    ##   menuitem <- gtkMenuItemNewWithLabel(gettext("rm"))
                                    ##   gSignalConnect(menuitem, "activate", function(data) {
                                    ##     rm(list=out, envir=.GlobalEnv)
                                    ##   })
                                    ##   menu$append(menuitem)
                                    ## }
                                    ## ## view
                                    ## menuitem <- gtkMenuItemNewWithLabel(gettext("View"))
                                    ## gSignalConnect(menuitem, "activate", function(data) {
                                    ##   View(obj)
                                    ## })
                                    ## menu$append(menuitem)
                                    ## ## fix?
                                    ## if(length(out) == 1) {
                                    ##   menuitem <- gtkMenuItemNewWithLabel(gettext("fix"))
                                    ##   gSignalConnect(menuitem, "activate", function(data) {
                                    ##     fix(obj)
                                    ##   })
                                    ## }
                                    ## menu$append(menuitem)
                                    
                                    ## popup menu                                    
                                    menu$popup(NULL, NULL, NULL, NULL,
                                               event$button,
                                               event$time)
                                  }
                                  FALSE
                                }
                                ## attach to button-press and popup-menu
                                gSignalConnect(widget, "button-press-event", on_button_pressed)
                                gSignalConnect(widget, "popup-menu", on_button_pressed)
                                
                              }
                              ))
## work with context menu
add_rm <- function(x, nm, menu) {
  menuitem <- gtkMenuItemNewWithLabel(gettext("rm"))
  gSignalConnect(menuitem, "activate", function(data) {
    rm(list=nm, envir=.GlobalEnv)
  })
  menu$append(menuitem)
}

view_vector <- function(x, nm, menu) {
  menuitem <- gtkMenuItemNewWithLabel(gettext("view"))
  gSignalConnect(menuitem, "activate", function(data) {
    w1 <- gbasicdialog(gettext("View a vector"), height=400)
    gtable(x, container=w1)
    w1$set_visible(TRUE)
  })
  menu$append(menuitem)
}


edit_vector <- function(x, nm, menu) {
  menuitem <- gtkMenuItemNewWithLabel(gettext("edit"))
  gSignalConnect(menuitem, "activate", function(data) {
    w1 <- gbasicdialog(gettext("Edit a vector"),
                       height=400,
                       handler=function(h,...) {
                         val <- tbl[,1]
                         where <- .GlobalEnv
                         assign(nm, val, where)
                       })
    tbl <- gdf(x, container=w1)
    w1$set_visible(TRUE)
  })
  menu$append(menuitem)
}


view_rect <- function(x, nm, menu) {
  menuitem <- gtkMenuItemNewWithLabel(gettext("view"))
  gSignalConnect(menuitem, "activate", function(data) {
    w1 <- gbasicdialog(gettext("View rectangular data"))
    gtable(x, container=w1)
    w1$set_visible(TRUE)
  })
  menu$append(menuitem)
}


edit_rect <- function(x, nm, menu) {
  menuitem <- gtkMenuItemNewWithLabel(gettext("edit"))
  gSignalConnect(menuitem, "activate", function(data) {
    w1 <- gbasicdialog(gettext("Edit rectangular data"), handler=function(h,...) {
      val <- tbl[,]
      where <- .GlobalEnv
      assign(nm, val, where)
    })
    tbl <- gdf(x, container=w1)
    w1$set_visible(TRUE)
  })
  menu$append(menuitem)
}


## Add action to popup menu based on x
popup_actions <- function(x, nm, menu) UseMethod("popup_actions")

popup_actions.default <- function(x, nm, menu) {
  if(!grepl("\\$", nm))
    add_rm(x, nm, menu)
}

pop_actions.logical <- popup_actions.character <- popup_actions.numeric <- function(x, nm, menu) {
  NextMethod()
  ## others
  view_vector(x, nm, menu)
  if(!grepl("\\$", nm))
    edit_vector(x, nm, menu)
}

popup_actions.data.frame <- function(x, nm, menu) {
  NextMethod()
  view_rect(x, nm, menu)
  if(!grepl("\\$", nm))
    edit_rect(x, nm, menu)


}
  
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gedit.R"
##' @include GWidget.R
NULL

## TODO: XXX drophandler -- doubles up!

##' Toolkit gedit constructor
##'
##' @param initial.msg initial.msg
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gedit guiWidgetsToolkitRGtk2
##' @S3method .gedit guiWidgetsToolkitRGtk2
.gedit.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                           text = "", width = 25, coerce.with = NULL, initial.msg=initial.msg,
                    handler = NULL,action = NULL, container = NULL, ... ) {
  GEdit$new( toolkit, text = text, width = width, coerce.with = coerce.with, initial.msg=initial.msg,
                    handler = handler,action = action, container = container, ...)
}


##' The GEdit class adds some methods beyond the spec: \code{set_error}, \code{clear_error}, \code{validate_value}
##'
##' @param ... passed to constructor
GEdit <- setRefClass("GEdit",
                            contains="GWidget",
                            fields=list(
                              init_msg="character",
                              init_msg_flag="logical",
                              completion="ANY",
                              validator="ANY"
                              ),
                            methods=list(
                              initialize=function( toolkit=NULL,
                                text = "", width = 25, coerce.with = NULL,
                                initial.msg="",
                                handler = NULL, action = NULL, container = NULL, ...) {

                                widget <<- gtkEntryNew()
                                widget$setWidthChars(width)
                                
                                initFields(block=widget,
                                           coerce_with=coerce.with,
                                           init_msg=initial.msg,
                                           init_msg_flag=FALSE,
                                           completion=NULL,
                                           validator=NULL,
                                           change_signal="activate"
                                           )

                                ## init msg
                                if(nchar(init_msg) > 0) {
                                  id <- gSignalConnect(widget, "focus-in-event", function(...) {
                                    clear_init_txt()
                                    FALSE
                                  })
                                  gSignalConnect(widget, "focus-out-event", function(...) {
                                    if(nchar(widget$getText()) == 0) {
                                      set_init_txt()
                                    }
                                    FALSE
                                  })
                                }
                                ## overwrite?
                                if(nchar(text) > 0)
                                  set_value(text)
                                
                                add_to_parent(container, .self, ...)


                                ## hard code drop handler
                                ## otherwise we have problems with doubling up (Can't
                                ## avoid the default call)
#                                add_drop_target(function(h,...) {
#                                  h$obj$set_value("")
#                                  focus(h$obj) <- TRUE
#                                  invoke_change_handler()
#                                })
                                
#                                handler_id <<- add_handler_changed(handler, action)
                                ## change handler on focus out event
                                add_handler_blur(function(...) invoke_change_handler())
                                
                                callSuper(toolkit)
                              },
                              set_value=function(value, index=TRUE, drop=TRUE, ...) {
                                clear_init_txt()
                                widget$selectRegion(0, -1) # select then replace
                                widget$setText(value)
                                widget$activate() # emit signal
                              },
                              get_value=function(index=TRUE, drop=TRUE, ...) {
                                if(!init_msg_flag)
                                  widget$getText()
                                else
                                  ""
                              },
                              set_init_txt=function() {
                                "set initial text, gray out"
                                widget$modifyText(GtkStateType[1], "gray")
                                widget$setText(init_msg)
                                init_msg_flag <<- TRUE
                              },
                              clear_init_txt=function() {
                                "clear out init text, set back to black"
                                widget$modifyText(GtkStateType[1], NULL) # should restore setting
                                if(init_msg_flag)
                                  widget$setText("")
                                init_msg_flag <<- FALSE
                                
                              },
                              get_items=function(i, j, ..., drop=TRUE) {
                                "i for index"
                                if(is.null(completion))
                                  return(character(0))
                                
                                store <- completion$GetModel()
                                nrows <- dim(store)[1]
                                store[i , ]
                              },
                              set_items=function(value, i, j, ...) {
                                if(is.null(completion)) {
                                  completion <<- gtkEntryCompletionNew()
                                   model <- rGtkDataFrame(data.frame(character(50000),stringsAsFactors=FALSE))
                                  completion$SetModel(model)
                                  completion$SetTextColumn(0)           # Columns count from 0 -- not 1

                                  ## set properties
                                  completion$setInlineCompletion(TRUE)
                                  completion$setInlineSelection(TRUE)

                                  widget$SetCompletion(completion)
                                }

                                store <- widget$GetCompletion()$GetModel()
                                nrows <- dim(store)[1]
                                n <- length(value)
                                if(n > nrows)
                                  value <- value[1:nrows]            # truncate
                                if(missing(i))
                                  i <- 1:n
                                store[i , ] <- value
                              },
                              get_visible = function() {
                                widget$getVisibility()
                              },

                              set_visible = function(value) {
                                widget$setInvisibleChar(42L) # asterisk
                                widget$setVisibility(as.logical(value))
                              },

                              get_editable=function() {
                                "Can we actually edit widget?"
                                widget$getEditable()
                              },
                              set_editable = function(value, j) {
                                widget$setEditable(as.logical(value))
                              },
                              ## Handler: changed -> clicked
                              ## add_handler_changed = function(handler, action=NULL, ...) {
                              ##   if(missing(handler) || is.null(handler))
                              ##     return()
                              ##   f <- function(h, widget, event, ...) {
                              ##     keyval <- event$GetKeyval()
                              ##     if(keyval == GDK_Return) {
                              ##       handler(h, widget, event, ...)
                              ##       return(TRUE)
                              ##     } else {
                              ##       return(FALSE)
                              ##     }
                              ##   }
                              ##   add_handler("activate", f, action=action, ...)
                              ## },
                             

                              ## Extra methods
                              set_icon = function(stock, where="start") { ## or end
                                where = GtkEntryIconPosition[ifelse(where == "end", "secondary", "primary")]
                                widget$setIconFromStock(where, getStockIconByName(stock))
                              },
                              set_icon_handler = function(callback, where="start") {
                                where = GtkEntryIconPosition[ifelse(where == "end", "secondary", "primary")]
                                widget$setIconActivatable(where, TRUE)
                                gSignalConnect(widget, "icon-press", callback)
                              },
                              set_validator = function(FUN) {
                                "Set a function to do the validation"
                                validator <<- FUN
                              },
                              validate_input = function() {
                                "Return logical indicating if input is valid"
                                if(is.null(validator))
                                  TRUE
                                else 
                                  validator(get_value())
                              },
                              set_invalid=function(value, msg=NULL) {
                                "Set invalid state with message"
                                if(value)
                                  set_error(msg)
                                else
                                  clear_error()
                                callSuper(value, msg)
                              },
                              set_error = function(msg) {
                                "Add error state and message to widget"
                                widget$setIconFromStock("primary", "gtk-no")
                                if(!missing(msg) && !is.null(msg))
                                  widget$setIconTooltipText("primary", msg)
                              },
                              clear_error = function() {
                                "Clear error message"
                                widget$setIconFromStock("primary", NULL)
                                widget$setIconTooltipText("primary", NULL)
                              }
                              ))

#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gformlayout.R"
##' @include GWidget.R
NULL

## sapcing is in need of fixing

##' Toolkit constructor
##'
##' @inheritParams gWidgets2::gformlayout
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @method .gformlayout guiWidgetsToolkitRGtk2
##' @S3method .gformlayout guiWidgetsToolkitRGtk2
.gformlayout.guiWidgetsToolkitRGtk2 <-  function(toolkit,
                                             align="left",
                                             spacing=5,
                                             container = NULL, ... ) {
  GFormLayout$new(toolkit,
             align,
             spacing,
             container=container ,...)
}


## a form layout -- really just a table
GFormLayout <- setRefClass("GFormLayout",
                           contains="GContainer",
                           fields=list(
                             align="character",
                             spacing="numeric",
                             lyt="ANY"
                             ),
                           methods=list(
                             initialize=function(toolkit=NULL,
                               align="left", spacing=5,
                               container=NULL,
                               ...) {
                               
                               initFields(align=align,
                                          spacing=spacing
                                          )
                               make_widget()
                               
                               add_to_parent(container, .self)
                               callSuper(toolkit, ...)
                             },
                             make_widget=function() {
                               widget <<- gtkTableNew(homogeneous=FALSE)
                               set_spacings(spacing)
                               block <<- widget
                             },
                             finalize=function() {
                               ## some cases one needs to call finalize to write table (gWidgetsWWW2)
                             },
                             set_spacings=function(row, col=row) {
                               "Method to adjust row and column space"
                               widget$setRowSpacings(row)
                               widget$setColSpacings(col)
                             },
                             add_child=function(child,  expand=NULL, fill=NULL, anchor=NULL, ..., label="") {
                               add_row(label, child, expand, fill, anchor, ...)
                             },
                             add_row=function(label, child, expand=NULL, fill=NULL, anchor=NULL, ...) {
                               "Add a row at end"
                               row <- no_rows()
                               
                               child_widget <- getBlock(child)

                               ## implement alignment and
                               align_amt <- switch(align,
                                                   "default"=1,
                                                   "right"=1,
                                                   "left"=0,
                                                   1)
                             
                               #print(list(expand, fill, anchor))
                               
                               xopts <- yopts <- c("shrink")
                               if(is.null(expand) || expand)
                                 xopts <- yopts <- c("expand", "shrink")
                               
                               if(is.null(fill)) fill <- TRUE
                               if(is.logical(fill) && fill)
                                 xopts <- yopts <- c("expand", "shrink", "fill")
                               if(is.character(fill)) {
                                 if(fill == "both") {
                                   xopts <- yopts <- c("expand", "shrink", "fill")
                                 } else if(fill == "x") {
                                   xopts <- c("expand", "shrink", "fill")
                                 } else if(fill == "y") {
                                   yopts <- c("expand", "shrink", "fill")
                                 }
                               }

                               ## 0,0 = top, 0.5 center. We center, as
                               ## otherwise widgets in boxes look
                               ## funny, as the boxes have some
                               ## padding.
                               
                               l <- gtkLabelNew(label); l$setAlignment(align_amt, 0.5)
                               widget$attach(l,
                                             0, 1, row, row + 1,
                                             xoptions=c("expand", "fill"),
                                             yoptions="fill"
                                             )

                               ## child alignment ...
                               if(!is.na(match("xalign", names(child_widget))))
                                 child_widget['xalign'] <- ifelse(is.null(anchor),
                                                                  0,
                                                                  (1 + anchor[1])/1)

                               widget$attach(child_widget,
                                             1, 2, row, row + 1,
                                             xoptions=xopts, yoptions=yopts
                                             )
                               ## bookkeeping
                               if(is(child, "GComponent"))
                                 child$set_parent(.self)

                               nms <- names(children)
                               children <<- c(children, child)
                               names(children) <<- c(nms, label)
                             },
                             get_value=function(...) sapply(children, svalue, simplify=FALSE),
                              set_value=function(value, ...) {
                               "value a named list matching children"
                               value <- as.list(value)
                               nms <- Filter(function(i) !is.na(match(i, names(children))), names(value))
                               sapply(nms, function(nm) {
                                 obj <- children[[nm]]
                                 svalue(obj) <- value[[nm]]
                               })
                             },
                             no_rows=function() widget$getNrows(),
                             ## Hacky way to set fonts
                             get_labels=function() {
                               kidz <- Map(function(x) x$getWidget(), widget$getChildren())
                               labels <- Filter(function(x) is(x, "GtkLabel"), kidz)
                               names(labels) <- sapply(labels, function(x) x$getText())
                               labels
                             },
                             set_font=function(label_value, value) {
                               "set font for a label which is specified by its value"
                               labels <- get_labels()
                               set_rgtk2_font(labels[[label_value]], value)
                             }
                             ))
                             
#line 1 "/home/tell029/iNZight/gWidgets2RGtk2/R/gprogressbar.R"
##' @include GWidget.R
NULL

##' Toolkit  constructor
##'
##' @inheritParams gWidgets2::gprogressbar
##' @export
##' @rdname gWidgets2RGtk2-undocumented
##' @seealso The documentation for this is found at \code{\link{gprogressbar}}.
##' @method .gprogressbar guiWidgetsToolkitRGtk2
##' @S3method .gprogressbar guiWidgetsToolkitRGtk2
.gprogressbar.guiWidgetsToolkitRGtk2 <- function(toolkit, value, container, ...) {
  GProgressBar$new(toolkit, value, container, ...)
}

##' For RGtk2, the Gprogressbar class has the extra reference method
##' \code{set_border}. The \code{border} argument has been deprecated.
##' @rdname gWidgets2RGtk2-package
GProgressBar <- setRefClass("GProgressBar",
                            contains="GWidget",
                            methods=list(
                              initialize=function(toolkit=NULL, value, container, ...) {
                                
                                widget <<- gtkProgressBar()

                                if(!missing(value))
                                  set_value(value)
                                
                                initFields(block=widget)
                                
                                add_to_parent(container, .self, ...)

                                callSuper(toolkit)
                              },
                              set_value=function(value, index=TRUE, drop=TRUE, ...) {
                                if(is.null(value)) {
                                  widget$pulse()
                                } else {
                                  value <- as.numeric(value)
                                  frac <- (value/100) %% 1
                                  widget$setFraction(frac)
                                }
                              },
                              get_value=function(index=TRUE, drop=TRUE, ...) {
                                as.integer(widget$getFraction() * 100)
                              }
                              ))


